// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IP_STACCATO_XML.hxx"

// NODE
// 

const NODE::ID_optional& NODE::
ID () const
{
  return this->ID_;
}

NODE::ID_optional& NODE::
ID ()
{
  return this->ID_;
}

void NODE::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

void NODE::
ID (const ID_optional& x)
{
  this->ID_ = x;
}

void NODE::
ID (::std::auto_ptr< ID_type > x)
{
  this->ID_.set (x);
}

const NODE::X_optional& NODE::
X () const
{
  return this->X_;
}

NODE::X_optional& NODE::
X ()
{
  return this->X_;
}

void NODE::
X (const X_type& x)
{
  this->X_.set (x);
}

void NODE::
X (const X_optional& x)
{
  this->X_ = x;
}

void NODE::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const NODE::Y_optional& NODE::
Y () const
{
  return this->Y_;
}

NODE::Y_optional& NODE::
Y ()
{
  return this->Y_;
}

void NODE::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void NODE::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void NODE::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const NODE::Z_optional& NODE::
Z () const
{
  return this->Z_;
}

NODE::Z_optional& NODE::
Z ()
{
  return this->Z_;
}

void NODE::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void NODE::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void NODE::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}

const NODE::TRANSLATETO_sequence& NODE::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

NODE::TRANSLATETO_sequence& NODE::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void NODE::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}


// TRANSLATETO
// 

const TRANSLATETO::Source_optional& TRANSLATETO::
Source () const
{
  return this->Source_;
}

TRANSLATETO::Source_optional& TRANSLATETO::
Source ()
{
  return this->Source_;
}

void TRANSLATETO::
Source (const Source_type& x)
{
  this->Source_.set (x);
}

void TRANSLATETO::
Source (const Source_optional& x)
{
  this->Source_ = x;
}

void TRANSLATETO::
Source (::std::auto_ptr< Source_type > x)
{
  this->Source_.set (x);
}

const TRANSLATETO::Target_optional& TRANSLATETO::
Target () const
{
  return this->Target_;
}

TRANSLATETO::Target_optional& TRANSLATETO::
Target ()
{
  return this->Target_;
}

void TRANSLATETO::
Target (const Target_type& x)
{
  this->Target_.set (x);
}

void TRANSLATETO::
Target (const Target_optional& x)
{
  this->Target_ = x;
}

void TRANSLATETO::
Target (::std::auto_ptr< Target_type > x)
{
  this->Target_.set (x);
}


// ELEMENT
// 

const ELEMENT::ID_optional& ELEMENT::
ID () const
{
  return this->ID_;
}

ELEMENT::ID_optional& ELEMENT::
ID ()
{
  return this->ID_;
}

void ELEMENT::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

void ELEMENT::
ID (const ID_optional& x)
{
  this->ID_ = x;
}

void ELEMENT::
ID (::std::auto_ptr< ID_type > x)
{
  this->ID_.set (x);
}

const ELEMENT::NODECONNECT_optional& ELEMENT::
NODECONNECT () const
{
  return this->NODECONNECT_;
}

ELEMENT::NODECONNECT_optional& ELEMENT::
NODECONNECT ()
{
  return this->NODECONNECT_;
}

void ELEMENT::
NODECONNECT (const NODECONNECT_type& x)
{
  this->NODECONNECT_.set (x);
}

void ELEMENT::
NODECONNECT (const NODECONNECT_optional& x)
{
  this->NODECONNECT_ = x;
}

void ELEMENT::
NODECONNECT (::std::auto_ptr< NODECONNECT_type > x)
{
  this->NODECONNECT_.set (x);
}

const ELEMENT::TRANSLATETO_sequence& ELEMENT::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

ELEMENT::TRANSLATETO_sequence& ELEMENT::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void ELEMENT::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}

const ELEMENT::Type_optional& ELEMENT::
Type () const
{
  return this->Type_;
}

ELEMENT::Type_optional& ELEMENT::
Type ()
{
  return this->Type_;
}

void ELEMENT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void ELEMENT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void ELEMENT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// NODESET
// 

const NODESET::LIST_optional& NODESET::
LIST () const
{
  return this->LIST_;
}

NODESET::LIST_optional& NODESET::
LIST ()
{
  return this->LIST_;
}

void NODESET::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void NODESET::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void NODESET::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const NODESET::Name_optional& NODESET::
Name () const
{
  return this->Name_;
}

NODESET::Name_optional& NODESET::
Name ()
{
  return this->Name_;
}

void NODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void NODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void NODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// REAL
// 

const REAL::X_optional& REAL::
X () const
{
  return this->X_;
}

REAL::X_optional& REAL::
X ()
{
  return this->X_;
}

void REAL::
X (const X_type& x)
{
  this->X_.set (x);
}

void REAL::
X (const X_optional& x)
{
  this->X_ = x;
}

void REAL::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const REAL::Y_optional& REAL::
Y () const
{
  return this->Y_;
}

REAL::Y_optional& REAL::
Y ()
{
  return this->Y_;
}

void REAL::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void REAL::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void REAL::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const REAL::Z_optional& REAL::
Z () const
{
  return this->Z_;
}

REAL::Z_optional& REAL::
Z ()
{
  return this->Z_;
}

void REAL::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void REAL::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void REAL::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// IMAGINARY
// 

const IMAGINARY::X_optional& IMAGINARY::
X () const
{
  return this->X_;
}

IMAGINARY::X_optional& IMAGINARY::
X ()
{
  return this->X_;
}

void IMAGINARY::
X (const X_type& x)
{
  this->X_.set (x);
}

void IMAGINARY::
X (const X_optional& x)
{
  this->X_ = x;
}

void IMAGINARY::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const IMAGINARY::Y_optional& IMAGINARY::
Y () const
{
  return this->Y_;
}

IMAGINARY::Y_optional& IMAGINARY::
Y ()
{
  return this->Y_;
}

void IMAGINARY::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void IMAGINARY::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void IMAGINARY::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const IMAGINARY::Z_optional& IMAGINARY::
Z () const
{
  return this->Z_;
}

IMAGINARY::Z_optional& IMAGINARY::
Z ()
{
  return this->Z_;
}

void IMAGINARY::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void IMAGINARY::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void IMAGINARY::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// STACCATO_XML
// 

const STACCATO_XML::NODE_sequence& STACCATO_XML::
NODE () const
{
  return this->NODE_;
}

STACCATO_XML::NODE_sequence& STACCATO_XML::
NODE ()
{
  return this->NODE_;
}

void STACCATO_XML::
NODE (const NODE_sequence& s)
{
  this->NODE_ = s;
}

const STACCATO_XML::TRANSLATETO_sequence& STACCATO_XML::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

STACCATO_XML::TRANSLATETO_sequence& STACCATO_XML::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void STACCATO_XML::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}

const STACCATO_XML::ELEMENT_sequence& STACCATO_XML::
ELEMENT () const
{
  return this->ELEMENT_;
}

STACCATO_XML::ELEMENT_sequence& STACCATO_XML::
ELEMENT ()
{
  return this->ELEMENT_;
}

void STACCATO_XML::
ELEMENT (const ELEMENT_sequence& s)
{
  this->ELEMENT_ = s;
}

const STACCATO_XML::NODESET_sequence& STACCATO_XML::
NODESET () const
{
  return this->NODESET_;
}

STACCATO_XML::NODESET_sequence& STACCATO_XML::
NODESET ()
{
  return this->NODESET_;
}

void STACCATO_XML::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const STACCATO_XML::REAL_sequence& STACCATO_XML::
REAL () const
{
  return this->REAL_;
}

STACCATO_XML::REAL_sequence& STACCATO_XML::
REAL ()
{
  return this->REAL_;
}

void STACCATO_XML::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const STACCATO_XML::IMAGINARY_sequence& STACCATO_XML::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

STACCATO_XML::IMAGINARY_sequence& STACCATO_XML::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void STACCATO_XML::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}

const STACCATO_XML::FILEIMPORT_sequence& STACCATO_XML::
FILEIMPORT () const
{
  return this->FILEIMPORT_;
}

STACCATO_XML::FILEIMPORT_sequence& STACCATO_XML::
FILEIMPORT ()
{
  return this->FILEIMPORT_;
}

void STACCATO_XML::
FILEIMPORT (const FILEIMPORT_sequence& s)
{
  this->FILEIMPORT_ = s;
}

const STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS () const
{
  return this->ANALYSIS_;
}

STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS ()
{
  return this->ANALYSIS_;
}

void STACCATO_XML::
ANALYSIS (const ANALYSIS_sequence& s)
{
  this->ANALYSIS_ = s;
}

const STACCATO_XML::FREQUENCY_sequence& STACCATO_XML::
FREQUENCY () const
{
  return this->FREQUENCY_;
}

STACCATO_XML::FREQUENCY_sequence& STACCATO_XML::
FREQUENCY ()
{
  return this->FREQUENCY_;
}

void STACCATO_XML::
FREQUENCY (const FREQUENCY_sequence& s)
{
  this->FREQUENCY_ = s;
}

const STACCATO_XML::MATERIALS_sequence& STACCATO_XML::
MATERIALS () const
{
  return this->MATERIALS_;
}

STACCATO_XML::MATERIALS_sequence& STACCATO_XML::
MATERIALS ()
{
  return this->MATERIALS_;
}

void STACCATO_XML::
MATERIALS (const MATERIALS_sequence& s)
{
  this->MATERIALS_ = s;
}

const STACCATO_XML::SECTIONS_sequence& STACCATO_XML::
SECTIONS () const
{
  return this->SECTIONS_;
}

STACCATO_XML::SECTIONS_sequence& STACCATO_XML::
SECTIONS ()
{
  return this->SECTIONS_;
}

void STACCATO_XML::
SECTIONS (const SECTIONS_sequence& s)
{
  this->SECTIONS_ = s;
}

const STACCATO_XML::NODES_sequence& STACCATO_XML::
NODES () const
{
  return this->NODES_;
}

STACCATO_XML::NODES_sequence& STACCATO_XML::
NODES ()
{
  return this->NODES_;
}

void STACCATO_XML::
NODES (const NODES_sequence& s)
{
  this->NODES_ = s;
}

const STACCATO_XML::ELEMENTS_sequence& STACCATO_XML::
ELEMENTS () const
{
  return this->ELEMENTS_;
}

STACCATO_XML::ELEMENTS_sequence& STACCATO_XML::
ELEMENTS ()
{
  return this->ELEMENTS_;
}

void STACCATO_XML::
ELEMENTS (const ELEMENTS_sequence& s)
{
  this->ELEMENTS_ = s;
}

const STACCATO_XML::SETS_sequence& STACCATO_XML::
SETS () const
{
  return this->SETS_;
}

STACCATO_XML::SETS_sequence& STACCATO_XML::
SETS ()
{
  return this->SETS_;
}

void STACCATO_XML::
SETS (const SETS_sequence& s)
{
  this->SETS_ = s;
}

const STACCATO_XML::LOADS_sequence& STACCATO_XML::
LOADS () const
{
  return this->LOADS_;
}

STACCATO_XML::LOADS_sequence& STACCATO_XML::
LOADS ()
{
  return this->LOADS_;
}

void STACCATO_XML::
LOADS (const LOADS_sequence& s)
{
  this->LOADS_ = s;
}

const STACCATO_XML::BC_sequence& STACCATO_XML::
BC () const
{
  return this->BC_;
}

STACCATO_XML::BC_sequence& STACCATO_XML::
BC ()
{
  return this->BC_;
}

void STACCATO_XML::
BC (const BC_sequence& s)
{
  this->BC_ = s;
}

const STACCATO_XML::COUPLE_sequence& STACCATO_XML::
COUPLE () const
{
  return this->COUPLE_;
}

STACCATO_XML::COUPLE_sequence& STACCATO_XML::
COUPLE ()
{
  return this->COUPLE_;
}

void STACCATO_XML::
COUPLE (const COUPLE_sequence& s)
{
  this->COUPLE_ = s;
}


// FILEIMPORT
// 

const FILEIMPORT::FILE_optional& FILEIMPORT::
FILE () const
{
  return this->FILE_;
}

FILEIMPORT::FILE_optional& FILEIMPORT::
FILE ()
{
  return this->FILE_;
}

void FILEIMPORT::
FILE (const FILE_type& x)
{
  this->FILE_.set (x);
}

void FILEIMPORT::
FILE (const FILE_optional& x)
{
  this->FILE_ = x;
}

void FILEIMPORT::
FILE (::std::auto_ptr< FILE_type > x)
{
  this->FILE_.set (x);
}

const FILEIMPORT::IMPORT_sequence& FILEIMPORT::
IMPORT () const
{
  return this->IMPORT_;
}

FILEIMPORT::IMPORT_sequence& FILEIMPORT::
IMPORT ()
{
  return this->IMPORT_;
}

void FILEIMPORT::
IMPORT (const IMPORT_sequence& s)
{
  this->IMPORT_ = s;
}

const FILEIMPORT::Name_optional& FILEIMPORT::
Name () const
{
  return this->Name_;
}

FILEIMPORT::Name_optional& FILEIMPORT::
Name ()
{
  return this->Name_;
}

void FILEIMPORT::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void FILEIMPORT::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void FILEIMPORT::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const FILEIMPORT::Type_optional& FILEIMPORT::
Type () const
{
  return this->Type_;
}

FILEIMPORT::Type_optional& FILEIMPORT::
Type ()
{
  return this->Type_;
}

void FILEIMPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FILEIMPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FILEIMPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// ANALYSIS
// 

const ANALYSIS::NAME_optional& ANALYSIS::
NAME () const
{
  return this->NAME_;
}

ANALYSIS::NAME_optional& ANALYSIS::
NAME ()
{
  return this->NAME_;
}

void ANALYSIS::
NAME (const NAME_type& x)
{
  this->NAME_.set (x);
}

void ANALYSIS::
NAME (const NAME_optional& x)
{
  this->NAME_ = x;
}

void ANALYSIS::
NAME (::std::auto_ptr< NAME_type > x)
{
  this->NAME_.set (x);
}

const ANALYSIS::TYPE_optional& ANALYSIS::
TYPE () const
{
  return this->TYPE_;
}

ANALYSIS::TYPE_optional& ANALYSIS::
TYPE ()
{
  return this->TYPE_;
}

void ANALYSIS::
TYPE (const TYPE_type& x)
{
  this->TYPE_.set (x);
}

void ANALYSIS::
TYPE (const TYPE_optional& x)
{
  this->TYPE_ = x;
}

void ANALYSIS::
TYPE (::std::auto_ptr< TYPE_type > x)
{
  this->TYPE_.set (x);
}


// FREQUENCY
// 

const FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ () const
{
  return this->START_FREQ_;
}

FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ ()
{
  return this->START_FREQ_;
}

void FREQUENCY::
START_FREQ (const START_FREQ_type& x)
{
  this->START_FREQ_.set (x);
}

void FREQUENCY::
START_FREQ (const START_FREQ_optional& x)
{
  this->START_FREQ_ = x;
}

void FREQUENCY::
START_FREQ (::std::auto_ptr< START_FREQ_type > x)
{
  this->START_FREQ_.set (x);
}

const FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ () const
{
  return this->END_FREQ_;
}

FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ ()
{
  return this->END_FREQ_;
}

void FREQUENCY::
END_FREQ (const END_FREQ_type& x)
{
  this->END_FREQ_.set (x);
}

void FREQUENCY::
END_FREQ (const END_FREQ_optional& x)
{
  this->END_FREQ_ = x;
}

void FREQUENCY::
END_FREQ (::std::auto_ptr< END_FREQ_type > x)
{
  this->END_FREQ_.set (x);
}

const FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ () const
{
  return this->STEP_FREQ_;
}

FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ ()
{
  return this->STEP_FREQ_;
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_type& x)
{
  this->STEP_FREQ_.set (x);
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_optional& x)
{
  this->STEP_FREQ_ = x;
}

void FREQUENCY::
STEP_FREQ (::std::auto_ptr< STEP_FREQ_type > x)
{
  this->STEP_FREQ_.set (x);
}

const FREQUENCY::Type_optional& FREQUENCY::
Type () const
{
  return this->Type_;
}

FREQUENCY::Type_optional& FREQUENCY::
Type ()
{
  return this->Type_;
}

void FREQUENCY::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FREQUENCY::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FREQUENCY::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// MATERIALS
// 

const MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL () const
{
  return this->MATERIAL_;
}

MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL ()
{
  return this->MATERIAL_;
}

void MATERIALS::
MATERIAL (const MATERIAL_sequence& s)
{
  this->MATERIAL_ = s;
}


// SECTIONS
// 

const SECTIONS::SECTION_sequence& SECTIONS::
SECTION () const
{
  return this->SECTION_;
}

SECTIONS::SECTION_sequence& SECTIONS::
SECTION ()
{
  return this->SECTION_;
}

void SECTIONS::
SECTION (const SECTION_sequence& s)
{
  this->SECTION_ = s;
}


// NODES
// 

const NODES::NODE_sequence& NODES::
NODE () const
{
  return this->NODE_;
}

NODES::NODE_sequence& NODES::
NODE ()
{
  return this->NODE_;
}

void NODES::
NODE (const NODE_sequence& s)
{
  this->NODE_ = s;
}


// ELEMENTS
// 

const ELEMENTS::ELEMENT_sequence& ELEMENTS::
ELEMENT () const
{
  return this->ELEMENT_;
}

ELEMENTS::ELEMENT_sequence& ELEMENTS::
ELEMENT ()
{
  return this->ELEMENT_;
}

void ELEMENTS::
ELEMENT (const ELEMENT_sequence& s)
{
  this->ELEMENT_ = s;
}


// SETS
// 

const SETS::ELEMENTSET_sequence& SETS::
ELEMENTSET () const
{
  return this->ELEMENTSET_;
}

SETS::ELEMENTSET_sequence& SETS::
ELEMENTSET ()
{
  return this->ELEMENTSET_;
}

void SETS::
ELEMENTSET (const ELEMENTSET_sequence& s)
{
  this->ELEMENTSET_ = s;
}

const SETS::NODESET_sequence& SETS::
NODESET () const
{
  return this->NODESET_;
}

SETS::NODESET_sequence& SETS::
NODESET ()
{
  return this->NODESET_;
}

void SETS::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}


// LOADS
// 

const LOADS::LOAD_sequence& LOADS::
LOAD () const
{
  return this->LOAD_;
}

LOADS::LOAD_sequence& LOADS::
LOAD ()
{
  return this->LOAD_;
}

void LOADS::
LOAD (const LOAD_sequence& s)
{
  this->LOAD_ = s;
}


// BC
// 

const BC::DBC_sequence& BC::
DBC () const
{
  return this->DBC_;
}

BC::DBC_sequence& BC::
DBC ()
{
  return this->DBC_;
}

void BC::
DBC (const DBC_sequence& s)
{
  this->DBC_ = s;
}


// COUPLE
// 

const COUPLE::Part_sequence& COUPLE::
Part () const
{
  return this->Part_;
}

COUPLE::Part_sequence& COUPLE::
Part ()
{
  return this->Part_;
}

void COUPLE::
Part (const Part_sequence& s)
{
  this->Part_ = s;
}

const COUPLE::Type_optional& COUPLE::
Type () const
{
  return this->Type_;
}

COUPLE::Type_optional& COUPLE::
Type ()
{
  return this->Type_;
}

void COUPLE::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void COUPLE::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void COUPLE::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// IMPORT
// 

const IMPORT::LIST_optional& IMPORT::
LIST () const
{
  return this->LIST_;
}

IMPORT::LIST_optional& IMPORT::
LIST ()
{
  return this->LIST_;
}

void IMPORT::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void IMPORT::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void IMPORT::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const IMPORT::NODE_sequence& IMPORT::
NODE () const
{
  return this->NODE_;
}

IMPORT::NODE_sequence& IMPORT::
NODE ()
{
  return this->NODE_;
}

void IMPORT::
NODE (const NODE_sequence& s)
{
  this->NODE_ = s;
}

const IMPORT::ELEMENT_sequence& IMPORT::
ELEMENT () const
{
  return this->ELEMENT_;
}

IMPORT::ELEMENT_sequence& IMPORT::
ELEMENT ()
{
  return this->ELEMENT_;
}

void IMPORT::
ELEMENT (const ELEMENT_sequence& s)
{
  this->ELEMENT_ = s;
}

const IMPORT::TRANSLATETO_sequence& IMPORT::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

IMPORT::TRANSLATETO_sequence& IMPORT::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void IMPORT::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}

const IMPORT::Type_optional& IMPORT::
Type () const
{
  return this->Type_;
}

IMPORT::Type_optional& IMPORT::
Type ()
{
  return this->Type_;
}

void IMPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void IMPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void IMPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// MATERIAL
// 

const MATERIAL::E_optional& MATERIAL::
E () const
{
  return this->E_;
}

MATERIAL::E_optional& MATERIAL::
E ()
{
  return this->E_;
}

void MATERIAL::
E (const E_type& x)
{
  this->E_.set (x);
}

void MATERIAL::
E (const E_optional& x)
{
  this->E_ = x;
}

void MATERIAL::
E (::std::auto_ptr< E_type > x)
{
  this->E_.set (x);
}

const MATERIAL::nu_optional& MATERIAL::
nu () const
{
  return this->nu_;
}

MATERIAL::nu_optional& MATERIAL::
nu ()
{
  return this->nu_;
}

void MATERIAL::
nu (const nu_type& x)
{
  this->nu_.set (x);
}

void MATERIAL::
nu (const nu_optional& x)
{
  this->nu_ = x;
}

void MATERIAL::
nu (::std::auto_ptr< nu_type > x)
{
  this->nu_.set (x);
}

const MATERIAL::rho_optional& MATERIAL::
rho () const
{
  return this->rho_;
}

MATERIAL::rho_optional& MATERIAL::
rho ()
{
  return this->rho_;
}

void MATERIAL::
rho (const rho_type& x)
{
  this->rho_.set (x);
}

void MATERIAL::
rho (const rho_optional& x)
{
  this->rho_ = x;
}

void MATERIAL::
rho (::std::auto_ptr< rho_type > x)
{
  this->rho_.set (x);
}

const MATERIAL::eta_optional& MATERIAL::
eta () const
{
  return this->eta_;
}

MATERIAL::eta_optional& MATERIAL::
eta ()
{
  return this->eta_;
}

void MATERIAL::
eta (const eta_type& x)
{
  this->eta_.set (x);
}

void MATERIAL::
eta (const eta_optional& x)
{
  this->eta_ = x;
}

void MATERIAL::
eta (::std::auto_ptr< eta_type > x)
{
  this->eta_.set (x);
}

const MATERIAL::Name_optional& MATERIAL::
Name () const
{
  return this->Name_;
}

MATERIAL::Name_optional& MATERIAL::
Name ()
{
  return this->Name_;
}

void MATERIAL::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void MATERIAL::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void MATERIAL::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const MATERIAL::Type_optional& MATERIAL::
Type () const
{
  return this->Type_;
}

MATERIAL::Type_optional& MATERIAL::
Type ()
{
  return this->Type_;
}

void MATERIAL::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void MATERIAL::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void MATERIAL::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// SECTION
// 

const SECTION::ELEMENTSET_optional& SECTION::
ELEMENTSET () const
{
  return this->ELEMENTSET_;
}

SECTION::ELEMENTSET_optional& SECTION::
ELEMENTSET ()
{
  return this->ELEMENTSET_;
}

void SECTION::
ELEMENTSET (const ELEMENTSET_type& x)
{
  this->ELEMENTSET_.set (x);
}

void SECTION::
ELEMENTSET (const ELEMENTSET_optional& x)
{
  this->ELEMENTSET_ = x;
}

void SECTION::
ELEMENTSET (::std::auto_ptr< ELEMENTSET_type > x)
{
  this->ELEMENTSET_.set (x);
}

const SECTION::MATERIAL_optional& SECTION::
MATERIAL () const
{
  return this->MATERIAL_;
}

SECTION::MATERIAL_optional& SECTION::
MATERIAL ()
{
  return this->MATERIAL_;
}

void SECTION::
MATERIAL (const MATERIAL_type& x)
{
  this->MATERIAL_.set (x);
}

void SECTION::
MATERIAL (const MATERIAL_optional& x)
{
  this->MATERIAL_ = x;
}

void SECTION::
MATERIAL (::std::auto_ptr< MATERIAL_type > x)
{
  this->MATERIAL_.set (x);
}

const SECTION::Name_optional& SECTION::
Name () const
{
  return this->Name_;
}

SECTION::Name_optional& SECTION::
Name ()
{
  return this->Name_;
}

void SECTION::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void SECTION::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void SECTION::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// ELEMENTSET
// 

const ELEMENTSET::LIST_optional& ELEMENTSET::
LIST () const
{
  return this->LIST_;
}

ELEMENTSET::LIST_optional& ELEMENTSET::
LIST ()
{
  return this->LIST_;
}

void ELEMENTSET::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void ELEMENTSET::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void ELEMENTSET::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const ELEMENTSET::Name_optional& ELEMENTSET::
Name () const
{
  return this->Name_;
}

ELEMENTSET::Name_optional& ELEMENTSET::
Name ()
{
  return this->Name_;
}

void ELEMENTSET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ELEMENTSET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void ELEMENTSET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// LOAD
// 

const LOAD::REFERENCENODESET_sequence& LOAD::
REFERENCENODESET () const
{
  return this->REFERENCENODESET_;
}

LOAD::REFERENCENODESET_sequence& LOAD::
REFERENCENODESET ()
{
  return this->REFERENCENODESET_;
}

void LOAD::
REFERENCENODESET (const REFERENCENODESET_sequence& s)
{
  this->REFERENCENODESET_ = s;
}

const LOAD::REFERENCENODE_sequence& LOAD::
REFERENCENODE () const
{
  return this->REFERENCENODE_;
}

LOAD::REFERENCENODE_sequence& LOAD::
REFERENCENODE ()
{
  return this->REFERENCENODE_;
}

void LOAD::
REFERENCENODE (const REFERENCENODE_sequence& s)
{
  this->REFERENCENODE_ = s;
}

const LOAD::COUPLINGNODESET_sequence& LOAD::
COUPLINGNODESET () const
{
  return this->COUPLINGNODESET_;
}

LOAD::COUPLINGNODESET_sequence& LOAD::
COUPLINGNODESET ()
{
  return this->COUPLINGNODESET_;
}

void LOAD::
COUPLINGNODESET (const COUPLINGNODESET_sequence& s)
{
  this->COUPLINGNODESET_ = s;
}

const LOAD::NODESET_sequence& LOAD::
NODESET () const
{
  return this->NODESET_;
}

LOAD::NODESET_sequence& LOAD::
NODESET ()
{
  return this->NODESET_;
}

void LOAD::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const LOAD::REAL_sequence& LOAD::
REAL () const
{
  return this->REAL_;
}

LOAD::REAL_sequence& LOAD::
REAL ()
{
  return this->REAL_;
}

void LOAD::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const LOAD::IMAGINARY_sequence& LOAD::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

LOAD::IMAGINARY_sequence& LOAD::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void LOAD::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}

const LOAD::Type_optional& LOAD::
Type () const
{
  return this->Type_;
}

LOAD::Type_optional& LOAD::
Type ()
{
  return this->Type_;
}

void LOAD::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void LOAD::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void LOAD::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// DBC
// 

const DBC::NODESET_sequence& DBC::
NODESET () const
{
  return this->NODESET_;
}

DBC::NODESET_sequence& DBC::
NODESET ()
{
  return this->NODESET_;
}

void DBC::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const DBC::REAL_sequence& DBC::
REAL () const
{
  return this->REAL_;
}

DBC::REAL_sequence& DBC::
REAL ()
{
  return this->REAL_;
}

void DBC::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const DBC::IMAGINARY_sequence& DBC::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

DBC::IMAGINARY_sequence& DBC::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void DBC::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}


// Part
// 

const Part::NODESET_sequence& Part::
NODESET () const
{
  return this->NODESET_;
}

Part::NODESET_sequence& Part::
NODESET ()
{
  return this->NODESET_;
}

void Part::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const Part::Name_optional& Part::
Name () const
{
  return this->Name_;
}

Part::Name_optional& Part::
Name ()
{
  return this->Name_;
}

void Part::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void Part::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void Part::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// REFERENCENODESET
// 

const REFERENCENODESET::Name_optional& REFERENCENODESET::
Name () const
{
  return this->Name_;
}

REFERENCENODESET::Name_optional& REFERENCENODESET::
Name ()
{
  return this->Name_;
}

void REFERENCENODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void REFERENCENODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void REFERENCENODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// REFERENCENODE
// 

const REFERENCENODE::X_optional& REFERENCENODE::
X () const
{
  return this->X_;
}

REFERENCENODE::X_optional& REFERENCENODE::
X ()
{
  return this->X_;
}

void REFERENCENODE::
X (const X_type& x)
{
  this->X_.set (x);
}

void REFERENCENODE::
X (const X_optional& x)
{
  this->X_ = x;
}

void REFERENCENODE::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const REFERENCENODE::Y_optional& REFERENCENODE::
Y () const
{
  return this->Y_;
}

REFERENCENODE::Y_optional& REFERENCENODE::
Y ()
{
  return this->Y_;
}

void REFERENCENODE::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void REFERENCENODE::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void REFERENCENODE::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const REFERENCENODE::Z_optional& REFERENCENODE::
Z () const
{
  return this->Z_;
}

REFERENCENODE::Z_optional& REFERENCENODE::
Z ()
{
  return this->Z_;
}

void REFERENCENODE::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void REFERENCENODE::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void REFERENCENODE::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// COUPLINGNODESET
// 

const COUPLINGNODESET::Name_optional& COUPLINGNODESET::
Name () const
{
  return this->Name_;
}

COUPLINGNODESET::Name_optional& COUPLINGNODESET::
Name ()
{
  return this->Name_;
}

void COUPLINGNODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void COUPLINGNODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void COUPLINGNODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// NODE
//

NODE::
NODE ()
: ::xml_schema::type (),
  ID_ (this),
  X_ (this),
  Y_ (this),
  Z_ (this),
  TRANSLATETO_ (this)
{
}

NODE::
NODE (const NODE& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this)
{
}

NODE::
NODE (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  X_ (this),
  Y_ (this),
  Z_ (this),
  TRANSLATETO_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NODE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID
    //
    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ID_type > r (
        ID_traits::create (i, f, this));

      if (!this->ID_)
      {
        this->ID_.set (r);
        continue;
      }
    }

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }
}

NODE* NODE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODE (*this, f, c);
}

NODE& NODE::
operator= (const NODE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
  }

  return *this;
}

NODE::
~NODE ()
{
}

// TRANSLATETO
//

TRANSLATETO::
TRANSLATETO ()
: ::xml_schema::type (),
  Source_ (this),
  Target_ (this)
{
}

TRANSLATETO::
TRANSLATETO (const TRANSLATETO& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Source_ (x.Source_, f, this),
  Target_ (x.Target_, f, this)
{
}

TRANSLATETO::
TRANSLATETO (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Source_ (this),
  Target_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void TRANSLATETO::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Source" && n.namespace_ ().empty ())
    {
      this->Source_.set (Source_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Target" && n.namespace_ ().empty ())
    {
      this->Target_.set (Target_traits::create (i, f, this));
      continue;
    }
  }
}

TRANSLATETO* TRANSLATETO::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TRANSLATETO (*this, f, c);
}

TRANSLATETO& TRANSLATETO::
operator= (const TRANSLATETO& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Source_ = x.Source_;
    this->Target_ = x.Target_;
  }

  return *this;
}

TRANSLATETO::
~TRANSLATETO ()
{
}

// ELEMENT
//

ELEMENT::
ELEMENT ()
: ::xml_schema::type (),
  ID_ (this),
  NODECONNECT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
}

ELEMENT::
ELEMENT (const ELEMENT& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  NODECONNECT_ (x.NODECONNECT_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this),
  Type_ (x.Type_, f, this)
{
}

ELEMENT::
ELEMENT (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  NODECONNECT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ELEMENT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID
    //
    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ID_type > r (
        ID_traits::create (i, f, this));

      if (!this->ID_)
      {
        this->ID_.set (r);
        continue;
      }
    }

    // NODECONNECT
    //
    if (n.name () == "NODECONNECT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODECONNECT_type > r (
        NODECONNECT_traits::create (i, f, this));

      if (!this->NODECONNECT_)
      {
        this->NODECONNECT_.set (r);
        continue;
      }
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

ELEMENT* ELEMENT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENT (*this, f, c);
}

ELEMENT& ELEMENT::
operator= (const ELEMENT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->NODECONNECT_ = x.NODECONNECT_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
    this->Type_ = x.Type_;
  }

  return *this;
}

ELEMENT::
~ELEMENT ()
{
}

// NODESET
//

NODESET::
NODESET ()
: ::xml_schema::type (),
  LIST_ (this),
  Name_ (this)
{
}

NODESET::
NODESET (const NODESET& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  Name_ (x.Name_, f, this)
{
}

NODESET::
NODESET (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void NODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

NODESET* NODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODESET (*this, f, c);
}

NODESET& NODESET::
operator= (const NODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->Name_ = x.Name_;
  }

  return *this;
}

NODESET::
~NODESET ()
{
}

// REAL
//

REAL::
REAL ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

REAL::
REAL (const REAL& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

REAL::
REAL (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void REAL::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

REAL* REAL::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REAL (*this, f, c);
}

REAL& REAL::
operator= (const REAL& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

REAL::
~REAL ()
{
}

// IMAGINARY
//

IMAGINARY::
IMAGINARY ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

IMAGINARY::
IMAGINARY (const IMAGINARY& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

IMAGINARY::
IMAGINARY (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IMAGINARY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

IMAGINARY* IMAGINARY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IMAGINARY (*this, f, c);
}

IMAGINARY& IMAGINARY::
operator= (const IMAGINARY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

IMAGINARY::
~IMAGINARY ()
{
}

// STACCATO_XML
//

STACCATO_XML::
STACCATO_XML ()
: ::xml_schema::type (),
  NODE_ (this),
  TRANSLATETO_ (this),
  ELEMENT_ (this),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  FILEIMPORT_ (this),
  ANALYSIS_ (this),
  FREQUENCY_ (this),
  MATERIALS_ (this),
  SECTIONS_ (this),
  NODES_ (this),
  ELEMENTS_ (this),
  SETS_ (this),
  LOADS_ (this),
  BC_ (this),
  COUPLE_ (this)
{
}

STACCATO_XML::
STACCATO_XML (const STACCATO_XML& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODE_ (x.NODE_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this),
  ELEMENT_ (x.ELEMENT_, f, this),
  NODESET_ (x.NODESET_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this),
  FILEIMPORT_ (x.FILEIMPORT_, f, this),
  ANALYSIS_ (x.ANALYSIS_, f, this),
  FREQUENCY_ (x.FREQUENCY_, f, this),
  MATERIALS_ (x.MATERIALS_, f, this),
  SECTIONS_ (x.SECTIONS_, f, this),
  NODES_ (x.NODES_, f, this),
  ELEMENTS_ (x.ELEMENTS_, f, this),
  SETS_ (x.SETS_, f, this),
  LOADS_ (x.LOADS_, f, this),
  BC_ (x.BC_, f, this),
  COUPLE_ (x.COUPLE_, f, this)
{
}

STACCATO_XML::
STACCATO_XML (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODE_ (this),
  TRANSLATETO_ (this),
  ELEMENT_ (this),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  FILEIMPORT_ (this),
  ANALYSIS_ (this),
  FREQUENCY_ (this),
  MATERIALS_ (this),
  SECTIONS_ (this),
  NODES_ (this),
  ELEMENTS_ (this),
  SETS_ (this),
  LOADS_ (this),
  BC_ (this),
  COUPLE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void STACCATO_XML::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODE
    //
    if (n.name () == "NODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODE_type > r (
        NODE_traits::create (i, f, this));

      this->NODE_.push_back (r);
      continue;
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    // ELEMENT
    //
    if (n.name () == "ELEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENT_type > r (
        ELEMENT_traits::create (i, f, this));

      this->ELEMENT_.push_back (r);
      continue;
    }

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    // FILEIMPORT
    //
    if (n.name () == "FILEIMPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILEIMPORT_type > r (
        FILEIMPORT_traits::create (i, f, this));

      this->FILEIMPORT_.push_back (r);
      continue;
    }

    // ANALYSIS
    //
    if (n.name () == "ANALYSIS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ANALYSIS_type > r (
        ANALYSIS_traits::create (i, f, this));

      this->ANALYSIS_.push_back (r);
      continue;
    }

    // FREQUENCY
    //
    if (n.name () == "FREQUENCY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FREQUENCY_type > r (
        FREQUENCY_traits::create (i, f, this));

      this->FREQUENCY_.push_back (r);
      continue;
    }

    // MATERIALS
    //
    if (n.name () == "MATERIALS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIALS_type > r (
        MATERIALS_traits::create (i, f, this));

      this->MATERIALS_.push_back (r);
      continue;
    }

    // SECTIONS
    //
    if (n.name () == "SECTIONS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SECTIONS_type > r (
        SECTIONS_traits::create (i, f, this));

      this->SECTIONS_.push_back (r);
      continue;
    }

    // NODES
    //
    if (n.name () == "NODES" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODES_type > r (
        NODES_traits::create (i, f, this));

      this->NODES_.push_back (r);
      continue;
    }

    // ELEMENTS
    //
    if (n.name () == "ELEMENTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTS_type > r (
        ELEMENTS_traits::create (i, f, this));

      this->ELEMENTS_.push_back (r);
      continue;
    }

    // SETS
    //
    if (n.name () == "SETS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SETS_type > r (
        SETS_traits::create (i, f, this));

      this->SETS_.push_back (r);
      continue;
    }

    // LOADS
    //
    if (n.name () == "LOADS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOADS_type > r (
        LOADS_traits::create (i, f, this));

      this->LOADS_.push_back (r);
      continue;
    }

    // BC
    //
    if (n.name () == "BC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BC_type > r (
        BC_traits::create (i, f, this));

      this->BC_.push_back (r);
      continue;
    }

    // COUPLE
    //
    if (n.name () == "COUPLE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< COUPLE_type > r (
        COUPLE_traits::create (i, f, this));

      this->COUPLE_.push_back (r);
      continue;
    }

    break;
  }
}

STACCATO_XML* STACCATO_XML::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class STACCATO_XML (*this, f, c);
}

STACCATO_XML& STACCATO_XML::
operator= (const STACCATO_XML& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODE_ = x.NODE_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
    this->ELEMENT_ = x.ELEMENT_;
    this->NODESET_ = x.NODESET_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
    this->FILEIMPORT_ = x.FILEIMPORT_;
    this->ANALYSIS_ = x.ANALYSIS_;
    this->FREQUENCY_ = x.FREQUENCY_;
    this->MATERIALS_ = x.MATERIALS_;
    this->SECTIONS_ = x.SECTIONS_;
    this->NODES_ = x.NODES_;
    this->ELEMENTS_ = x.ELEMENTS_;
    this->SETS_ = x.SETS_;
    this->LOADS_ = x.LOADS_;
    this->BC_ = x.BC_;
    this->COUPLE_ = x.COUPLE_;
  }

  return *this;
}

STACCATO_XML::
~STACCATO_XML ()
{
}

// FILEIMPORT
//

FILEIMPORT::
FILEIMPORT ()
: ::xml_schema::type (),
  FILE_ (this),
  IMPORT_ (this),
  Name_ (this),
  Type_ (this)
{
}

FILEIMPORT::
FILEIMPORT (const FILEIMPORT& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FILE_ (x.FILE_, f, this),
  IMPORT_ (x.IMPORT_, f, this),
  Name_ (x.Name_, f, this),
  Type_ (x.Type_, f, this)
{
}

FILEIMPORT::
FILEIMPORT (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FILE_ (this),
  IMPORT_ (this),
  Name_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FILEIMPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FILE
    //
    if (n.name () == "FILE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILE_type > r (
        FILE_traits::create (i, f, this));

      if (!this->FILE_)
      {
        this->FILE_.set (r);
        continue;
      }
    }

    // IMPORT
    //
    if (n.name () == "IMPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMPORT_type > r (
        IMPORT_traits::create (i, f, this));

      this->IMPORT_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FILEIMPORT* FILEIMPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FILEIMPORT (*this, f, c);
}

FILEIMPORT& FILEIMPORT::
operator= (const FILEIMPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FILE_ = x.FILE_;
    this->IMPORT_ = x.IMPORT_;
    this->Name_ = x.Name_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FILEIMPORT::
~FILEIMPORT ()
{
}

// ANALYSIS
//

ANALYSIS::
ANALYSIS ()
: ::xml_schema::type (),
  NAME_ (this),
  TYPE_ (this)
{
}

ANALYSIS::
ANALYSIS (const ANALYSIS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NAME_ (x.NAME_, f, this),
  TYPE_ (x.TYPE_, f, this)
{
}

ANALYSIS::
ANALYSIS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NAME_ (this),
  TYPE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ANALYSIS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NAME
    //
    if (n.name () == "NAME" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NAME_type > r (
        NAME_traits::create (i, f, this));

      if (!this->NAME_)
      {
        this->NAME_.set (r);
        continue;
      }
    }

    // TYPE
    //
    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TYPE_type > r (
        TYPE_traits::create (i, f, this));

      if (!this->TYPE_)
      {
        this->TYPE_.set (r);
        continue;
      }
    }

    break;
  }
}

ANALYSIS* ANALYSIS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ANALYSIS (*this, f, c);
}

ANALYSIS& ANALYSIS::
operator= (const ANALYSIS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NAME_ = x.NAME_;
    this->TYPE_ = x.TYPE_;
  }

  return *this;
}

ANALYSIS::
~ANALYSIS ()
{
}

// FREQUENCY
//

FREQUENCY::
FREQUENCY ()
: ::xml_schema::type (),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
}

FREQUENCY::
FREQUENCY (const FREQUENCY& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  START_FREQ_ (x.START_FREQ_, f, this),
  END_FREQ_ (x.END_FREQ_, f, this),
  STEP_FREQ_ (x.STEP_FREQ_, f, this),
  Type_ (x.Type_, f, this)
{
}

FREQUENCY::
FREQUENCY (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FREQUENCY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // START_FREQ
    //
    if (n.name () == "START_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< START_FREQ_type > r (
        START_FREQ_traits::create (i, f, this));

      if (!this->START_FREQ_)
      {
        this->START_FREQ_.set (r);
        continue;
      }
    }

    // END_FREQ
    //
    if (n.name () == "END_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< END_FREQ_type > r (
        END_FREQ_traits::create (i, f, this));

      if (!this->END_FREQ_)
      {
        this->END_FREQ_.set (r);
        continue;
      }
    }

    // STEP_FREQ
    //
    if (n.name () == "STEP_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< STEP_FREQ_type > r (
        STEP_FREQ_traits::create (i, f, this));

      if (!this->STEP_FREQ_)
      {
        this->STEP_FREQ_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FREQUENCY* FREQUENCY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FREQUENCY (*this, f, c);
}

FREQUENCY& FREQUENCY::
operator= (const FREQUENCY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->START_FREQ_ = x.START_FREQ_;
    this->END_FREQ_ = x.END_FREQ_;
    this->STEP_FREQ_ = x.STEP_FREQ_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FREQUENCY::
~FREQUENCY ()
{
}

// MATERIALS
//

MATERIALS::
MATERIALS ()
: ::xml_schema::type (),
  MATERIAL_ (this)
{
}

MATERIALS::
MATERIALS (const MATERIALS& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MATERIAL_ (x.MATERIAL_, f, this)
{
}

MATERIALS::
MATERIALS (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MATERIAL_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MATERIALS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MATERIAL
    //
    if (n.name () == "MATERIAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIAL_type > r (
        MATERIAL_traits::create (i, f, this));

      this->MATERIAL_.push_back (r);
      continue;
    }

    break;
  }
}

MATERIALS* MATERIALS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIALS (*this, f, c);
}

MATERIALS& MATERIALS::
operator= (const MATERIALS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MATERIAL_ = x.MATERIAL_;
  }

  return *this;
}

MATERIALS::
~MATERIALS ()
{
}

// SECTIONS
//

SECTIONS::
SECTIONS ()
: ::xml_schema::type (),
  SECTION_ (this)
{
}

SECTIONS::
SECTIONS (const SECTIONS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SECTION_ (x.SECTION_, f, this)
{
}

SECTIONS::
SECTIONS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SECTION_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SECTIONS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SECTION
    //
    if (n.name () == "SECTION" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SECTION_type > r (
        SECTION_traits::create (i, f, this));

      this->SECTION_.push_back (r);
      continue;
    }

    break;
  }
}

SECTIONS* SECTIONS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SECTIONS (*this, f, c);
}

SECTIONS& SECTIONS::
operator= (const SECTIONS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SECTION_ = x.SECTION_;
  }

  return *this;
}

SECTIONS::
~SECTIONS ()
{
}

// NODES
//

NODES::
NODES ()
: ::xml_schema::type (),
  NODE_ (this)
{
}

NODES::
NODES (const NODES& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODE_ (x.NODE_, f, this)
{
}

NODES::
NODES (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NODES::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODE
    //
    if (n.name () == "NODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODE_type > r (
        NODE_traits::create (i, f, this));

      this->NODE_.push_back (r);
      continue;
    }

    break;
  }
}

NODES* NODES::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODES (*this, f, c);
}

NODES& NODES::
operator= (const NODES& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODE_ = x.NODE_;
  }

  return *this;
}

NODES::
~NODES ()
{
}

// ELEMENTS
//

ELEMENTS::
ELEMENTS ()
: ::xml_schema::type (),
  ELEMENT_ (this)
{
}

ELEMENTS::
ELEMENTS (const ELEMENTS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENT_ (x.ELEMENT_, f, this)
{
}

ELEMENTS::
ELEMENTS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ELEMENTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENT
    //
    if (n.name () == "ELEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENT_type > r (
        ELEMENT_traits::create (i, f, this));

      this->ELEMENT_.push_back (r);
      continue;
    }

    break;
  }
}

ELEMENTS* ELEMENTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENTS (*this, f, c);
}

ELEMENTS& ELEMENTS::
operator= (const ELEMENTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENT_ = x.ELEMENT_;
  }

  return *this;
}

ELEMENTS::
~ELEMENTS ()
{
}

// SETS
//

SETS::
SETS ()
: ::xml_schema::type (),
  ELEMENTSET_ (this),
  NODESET_ (this)
{
}

SETS::
SETS (const SETS& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENTSET_ (x.ELEMENTSET_, f, this),
  NODESET_ (x.NODESET_, f, this)
{
}

SETS::
SETS (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENTSET_ (this),
  NODESET_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SETS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENTSET
    //
    if (n.name () == "ELEMENTSET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTSET_type > r (
        ELEMENTSET_traits::create (i, f, this));

      this->ELEMENTSET_.push_back (r);
      continue;
    }

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    break;
  }
}

SETS* SETS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SETS (*this, f, c);
}

SETS& SETS::
operator= (const SETS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENTSET_ = x.ELEMENTSET_;
    this->NODESET_ = x.NODESET_;
  }

  return *this;
}

SETS::
~SETS ()
{
}

// LOADS
//

LOADS::
LOADS ()
: ::xml_schema::type (),
  LOAD_ (this)
{
}

LOADS::
LOADS (const LOADS& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LOAD_ (x.LOAD_, f, this)
{
}

LOADS::
LOADS (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LOAD_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LOADS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LOAD
    //
    if (n.name () == "LOAD" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOAD_type > r (
        LOAD_traits::create (i, f, this));

      this->LOAD_.push_back (r);
      continue;
    }

    break;
  }
}

LOADS* LOADS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOADS (*this, f, c);
}

LOADS& LOADS::
operator= (const LOADS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LOAD_ = x.LOAD_;
  }

  return *this;
}

LOADS::
~LOADS ()
{
}

// BC
//

BC::
BC ()
: ::xml_schema::type (),
  DBC_ (this)
{
}

BC::
BC (const BC& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DBC_ (x.DBC_, f, this)
{
}

BC::
BC (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DBC_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BC::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DBC
    //
    if (n.name () == "DBC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DBC_type > r (
        DBC_traits::create (i, f, this));

      this->DBC_.push_back (r);
      continue;
    }

    break;
  }
}

BC* BC::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BC (*this, f, c);
}

BC& BC::
operator= (const BC& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DBC_ = x.DBC_;
  }

  return *this;
}

BC::
~BC ()
{
}

// COUPLE
//

COUPLE::
COUPLE ()
: ::xml_schema::type (),
  Part_ (this),
  Type_ (this)
{
}

COUPLE::
COUPLE (const COUPLE& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Part_ (x.Part_, f, this),
  Type_ (x.Type_, f, this)
{
}

COUPLE::
COUPLE (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Part_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void COUPLE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Part
    //
    if (n.name () == "Part" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Part_type > r (
        Part_traits::create (i, f, this));

      this->Part_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

COUPLE* COUPLE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class COUPLE (*this, f, c);
}

COUPLE& COUPLE::
operator= (const COUPLE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Part_ = x.Part_;
    this->Type_ = x.Type_;
  }

  return *this;
}

COUPLE::
~COUPLE ()
{
}

// IMPORT
//

IMPORT::
IMPORT ()
: ::xml_schema::type (),
  LIST_ (this),
  NODE_ (this),
  ELEMENT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
}

IMPORT::
IMPORT (const IMPORT& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  NODE_ (x.NODE_, f, this),
  ELEMENT_ (x.ELEMENT_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this),
  Type_ (x.Type_, f, this)
{
}

IMPORT::
IMPORT (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  NODE_ (this),
  ELEMENT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void IMPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    // NODE
    //
    if (n.name () == "NODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODE_type > r (
        NODE_traits::create (i, f, this));

      this->NODE_.push_back (r);
      continue;
    }

    // ELEMENT
    //
    if (n.name () == "ELEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENT_type > r (
        ELEMENT_traits::create (i, f, this));

      this->ELEMENT_.push_back (r);
      continue;
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

IMPORT* IMPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IMPORT (*this, f, c);
}

IMPORT& IMPORT::
operator= (const IMPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->NODE_ = x.NODE_;
    this->ELEMENT_ = x.ELEMENT_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
    this->Type_ = x.Type_;
  }

  return *this;
}

IMPORT::
~IMPORT ()
{
}

// MATERIAL
//

MATERIAL::
MATERIAL ()
: ::xml_schema::type (),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
}

MATERIAL::
MATERIAL (const MATERIAL& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  E_ (x.E_, f, this),
  nu_ (x.nu_, f, this),
  rho_ (x.rho_, f, this),
  eta_ (x.eta_, f, this),
  Name_ (x.Name_, f, this),
  Type_ (x.Type_, f, this)
{
}

MATERIAL::
MATERIAL (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MATERIAL::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // E
    //
    if (n.name () == "E" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< E_type > r (
        E_traits::create (i, f, this));

      if (!this->E_)
      {
        this->E_.set (r);
        continue;
      }
    }

    // nu
    //
    if (n.name () == "nu" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nu_type > r (
        nu_traits::create (i, f, this));

      if (!this->nu_)
      {
        this->nu_.set (r);
        continue;
      }
    }

    // rho
    //
    if (n.name () == "rho" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rho_type > r (
        rho_traits::create (i, f, this));

      if (!this->rho_)
      {
        this->rho_.set (r);
        continue;
      }
    }

    // eta
    //
    if (n.name () == "eta" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eta_type > r (
        eta_traits::create (i, f, this));

      if (!this->eta_)
      {
        this->eta_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

MATERIAL* MATERIAL::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIAL (*this, f, c);
}

MATERIAL& MATERIAL::
operator= (const MATERIAL& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->E_ = x.E_;
    this->nu_ = x.nu_;
    this->rho_ = x.rho_;
    this->eta_ = x.eta_;
    this->Name_ = x.Name_;
    this->Type_ = x.Type_;
  }

  return *this;
}

MATERIAL::
~MATERIAL ()
{
}

// SECTION
//

SECTION::
SECTION ()
: ::xml_schema::type (),
  ELEMENTSET_ (this),
  MATERIAL_ (this),
  Name_ (this)
{
}

SECTION::
SECTION (const SECTION& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENTSET_ (x.ELEMENTSET_, f, this),
  MATERIAL_ (x.MATERIAL_, f, this),
  Name_ (x.Name_, f, this)
{
}

SECTION::
SECTION (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENTSET_ (this),
  MATERIAL_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SECTION::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENTSET
    //
    if (n.name () == "ELEMENTSET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTSET_type > r (
        ELEMENTSET_traits::create (i, f, this));

      if (!this->ELEMENTSET_)
      {
        this->ELEMENTSET_.set (r);
        continue;
      }
    }

    // MATERIAL
    //
    if (n.name () == "MATERIAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIAL_type > r (
        MATERIAL_traits::create (i, f, this));

      if (!this->MATERIAL_)
      {
        this->MATERIAL_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

SECTION* SECTION::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SECTION (*this, f, c);
}

SECTION& SECTION::
operator= (const SECTION& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENTSET_ = x.ELEMENTSET_;
    this->MATERIAL_ = x.MATERIAL_;
    this->Name_ = x.Name_;
  }

  return *this;
}

SECTION::
~SECTION ()
{
}

// ELEMENTSET
//

ELEMENTSET::
ELEMENTSET ()
: ::xml_schema::type (),
  LIST_ (this),
  Name_ (this)
{
}

ELEMENTSET::
ELEMENTSET (const ELEMENTSET& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  Name_ (x.Name_, f, this)
{
}

ELEMENTSET::
ELEMENTSET (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ELEMENTSET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

ELEMENTSET* ELEMENTSET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENTSET (*this, f, c);
}

ELEMENTSET& ELEMENTSET::
operator= (const ELEMENTSET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->Name_ = x.Name_;
  }

  return *this;
}

ELEMENTSET::
~ELEMENTSET ()
{
}

// LOAD
//

LOAD::
LOAD ()
: ::xml_schema::type (),
  REFERENCENODESET_ (this),
  REFERENCENODE_ (this),
  COUPLINGNODESET_ (this),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Type_ (this)
{
}

LOAD::
LOAD (const LOAD& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  REFERENCENODESET_ (x.REFERENCENODESET_, f, this),
  REFERENCENODE_ (x.REFERENCENODE_, f, this),
  COUPLINGNODESET_ (x.COUPLINGNODESET_, f, this),
  NODESET_ (x.NODESET_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this),
  Type_ (x.Type_, f, this)
{
}

LOAD::
LOAD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  REFERENCENODESET_ (this),
  REFERENCENODE_ (this),
  COUPLINGNODESET_ (this),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void LOAD::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // REFERENCENODESET
    //
    if (n.name () == "REFERENCENODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REFERENCENODESET_type > r (
        REFERENCENODESET_traits::create (i, f, this));

      this->REFERENCENODESET_.push_back (r);
      continue;
    }

    // REFERENCENODE
    //
    if (n.name () == "REFERENCENODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REFERENCENODE_type > r (
        REFERENCENODE_traits::create (i, f, this));

      this->REFERENCENODE_.push_back (r);
      continue;
    }

    // COUPLINGNODESET
    //
    if (n.name () == "COUPLINGNODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< COUPLINGNODESET_type > r (
        COUPLINGNODESET_traits::create (i, f, this));

      this->COUPLINGNODESET_.push_back (r);
      continue;
    }

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

LOAD* LOAD::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOAD (*this, f, c);
}

LOAD& LOAD::
operator= (const LOAD& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->REFERENCENODESET_ = x.REFERENCENODESET_;
    this->REFERENCENODE_ = x.REFERENCENODE_;
    this->COUPLINGNODESET_ = x.COUPLINGNODESET_;
    this->NODESET_ = x.NODESET_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
    this->Type_ = x.Type_;
  }

  return *this;
}

LOAD::
~LOAD ()
{
}

// DBC
//

DBC::
DBC ()
: ::xml_schema::type (),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this)
{
}

DBC::
DBC (const DBC& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this)
{
}

DBC::
DBC (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DBC::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    break;
  }
}

DBC* DBC::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DBC (*this, f, c);
}

DBC& DBC::
operator= (const DBC& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
  }

  return *this;
}

DBC::
~DBC ()
{
}

// Part
//

Part::
Part ()
: ::xml_schema::type (),
  NODESET_ (this),
  Name_ (this)
{
}

Part::
Part (const Part& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  Name_ (x.Name_, f, this)
{
}

Part::
Part (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Part::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

Part* Part::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Part (*this, f, c);
}

Part& Part::
operator= (const Part& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->Name_ = x.Name_;
  }

  return *this;
}

Part::
~Part ()
{
}

// REFERENCENODESET
//

REFERENCENODESET::
REFERENCENODESET ()
: ::xml_schema::type (),
  Name_ (this)
{
}

REFERENCENODESET::
REFERENCENODESET (const REFERENCENODESET& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

REFERENCENODESET::
REFERENCENODESET (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void REFERENCENODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

REFERENCENODESET* REFERENCENODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REFERENCENODESET (*this, f, c);
}

REFERENCENODESET& REFERENCENODESET::
operator= (const REFERENCENODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

REFERENCENODESET::
~REFERENCENODESET ()
{
}

// REFERENCENODE
//

REFERENCENODE::
REFERENCENODE ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

REFERENCENODE::
REFERENCENODE (const REFERENCENODE& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

REFERENCENODE::
REFERENCENODE (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void REFERENCENODE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

REFERENCENODE* REFERENCENODE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REFERENCENODE (*this, f, c);
}

REFERENCENODE& REFERENCENODE::
operator= (const REFERENCENODE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

REFERENCENODE::
~REFERENCENODE ()
{
}

// COUPLINGNODESET
//

COUPLINGNODESET::
COUPLINGNODESET ()
: ::xml_schema::type (),
  Name_ (this)
{
}

COUPLINGNODESET::
COUPLINGNODESET (const COUPLINGNODESET& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

COUPLINGNODESET::
COUPLINGNODESET (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void COUPLINGNODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

COUPLINGNODESET* COUPLINGNODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class COUPLINGNODESET (*this, f, c);
}

COUPLINGNODESET& COUPLINGNODESET::
operator= (const COUPLINGNODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

COUPLINGNODESET::
~COUPLINGNODESET ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::NODE >
NODE_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODE_ (isrc, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODE_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODE_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODE_ (isrc, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODE_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODE_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODE >
NODE_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODE > (
    ::NODE_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODE >
NODE_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::NODE > (
      ::NODE_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "NODE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODE > r (
      ::xsd::cxx::tree::traits< ::NODE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODE",
    "");
}

::std::auto_ptr< ::NODE >
NODE_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "NODE" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODE > r (
      ::xsd::cxx::tree::traits< ::NODE, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODE",
    "");
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::TRANSLATETO > (
      ::TRANSLATETO_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "TRANSLATETO" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TRANSLATETO > r (
      ::xsd::cxx::tree::traits< ::TRANSLATETO, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TRANSLATETO",
    "");
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "TRANSLATETO" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TRANSLATETO > r (
      ::xsd::cxx::tree::traits< ::TRANSLATETO, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TRANSLATETO",
    "");
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ELEMENT_ (isrc, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ELEMENT_ (isrc, h, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::ELEMENT_ (isrc, h, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ELEMENT_ (isrc, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ELEMENT_ (isrc, h, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::ELEMENT_ (isrc, h, f, p);
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::ELEMENT > (
    ::ELEMENT_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::ELEMENT > (
      ::ELEMENT_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "ELEMENT" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ELEMENT > r (
      ::xsd::cxx::tree::traits< ::ELEMENT, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ELEMENT",
    "");
}

::std::auto_ptr< ::ELEMENT >
ELEMENT_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "ELEMENT" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::ELEMENT > r (
      ::xsd::cxx::tree::traits< ::ELEMENT, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "ELEMENT",
    "");
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::NODESET > (
      ::NODESET_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "NODESET" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODESET > r (
      ::xsd::cxx::tree::traits< ::NODESET, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODESET",
    "");
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "NODESET" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODESET > r (
      ::xsd::cxx::tree::traits< ::NODESET, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODESET",
    "");
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::REAL > (
      ::REAL_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "REAL" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::REAL > r (
      ::xsd::cxx::tree::traits< ::REAL, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "REAL",
    "");
}

::std::auto_ptr< ::REAL >
REAL_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "REAL" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::REAL > r (
      ::xsd::cxx::tree::traits< ::REAL, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "REAL",
    "");
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::IMAGINARY > (
      ::IMAGINARY_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "IMAGINARY" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::IMAGINARY > r (
      ::xsd::cxx::tree::traits< ::IMAGINARY, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "IMAGINARY",
    "");
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "IMAGINARY" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::IMAGINARY > r (
      ::xsd::cxx::tree::traits< ::IMAGINARY, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "IMAGINARY",
    "");
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::STACCATO_XML > (
      ::STACCATO_XML_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

