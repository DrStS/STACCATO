// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IP_STACCATO_XML.hxx"

// STACCATO_XML
// 

const STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS () const
{
  return this->ANALYSIS_;
}

STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS ()
{
  return this->ANALYSIS_;
}

void STACCATO_XML::
ANALYSIS (const ANALYSIS_sequence& s)
{
  this->ANALYSIS_ = s;
}

const STACCATO_XML::FREQUENCY_sequence& STACCATO_XML::
FREQUENCY () const
{
  return this->FREQUENCY_;
}

STACCATO_XML::FREQUENCY_sequence& STACCATO_XML::
FREQUENCY ()
{
  return this->FREQUENCY_;
}

void STACCATO_XML::
FREQUENCY (const FREQUENCY_sequence& s)
{
  this->FREQUENCY_ = s;
}

const STACCATO_XML::MATERIALS_sequence& STACCATO_XML::
MATERIALS () const
{
  return this->MATERIALS_;
}

STACCATO_XML::MATERIALS_sequence& STACCATO_XML::
MATERIALS ()
{
  return this->MATERIALS_;
}

void STACCATO_XML::
MATERIALS (const MATERIALS_sequence& s)
{
  this->MATERIALS_ = s;
}

const STACCATO_XML::NODES_sequence& STACCATO_XML::
NODES () const
{
  return this->NODES_;
}

STACCATO_XML::NODES_sequence& STACCATO_XML::
NODES ()
{
  return this->NODES_;
}

void STACCATO_XML::
NODES (const NODES_sequence& s)
{
  this->NODES_ = s;
}

const STACCATO_XML::ELEMENTS_sequence& STACCATO_XML::
ELEMENTS () const
{
  return this->ELEMENTS_;
}

STACCATO_XML::ELEMENTS_sequence& STACCATO_XML::
ELEMENTS ()
{
  return this->ELEMENTS_;
}

void STACCATO_XML::
ELEMENTS (const ELEMENTS_sequence& s)
{
  this->ELEMENTS_ = s;
}

const STACCATO_XML::LOADS_sequence& STACCATO_XML::
LOADS () const
{
  return this->LOADS_;
}

STACCATO_XML::LOADS_sequence& STACCATO_XML::
LOADS ()
{
  return this->LOADS_;
}

void STACCATO_XML::
LOADS (const LOADS_sequence& s)
{
  this->LOADS_ = s;
}

const STACCATO_XML::BC_sequence& STACCATO_XML::
BC () const
{
  return this->BC_;
}

STACCATO_XML::BC_sequence& STACCATO_XML::
BC ()
{
  return this->BC_;
}

void STACCATO_XML::
BC (const BC_sequence& s)
{
  this->BC_ = s;
}


// ANALYSIS
// 

const ANALYSIS::NAME_optional& ANALYSIS::
NAME () const
{
  return this->NAME_;
}

ANALYSIS::NAME_optional& ANALYSIS::
NAME ()
{
  return this->NAME_;
}

void ANALYSIS::
NAME (const NAME_type& x)
{
  this->NAME_.set (x);
}

void ANALYSIS::
NAME (const NAME_optional& x)
{
  this->NAME_ = x;
}

void ANALYSIS::
NAME (::std::auto_ptr< NAME_type > x)
{
  this->NAME_.set (x);
}

const ANALYSIS::TYPE_optional& ANALYSIS::
TYPE () const
{
  return this->TYPE_;
}

ANALYSIS::TYPE_optional& ANALYSIS::
TYPE ()
{
  return this->TYPE_;
}

void ANALYSIS::
TYPE (const TYPE_type& x)
{
  this->TYPE_.set (x);
}

void ANALYSIS::
TYPE (const TYPE_optional& x)
{
  this->TYPE_ = x;
}

void ANALYSIS::
TYPE (::std::auto_ptr< TYPE_type > x)
{
  this->TYPE_.set (x);
}


// FREQUENCY
// 

const FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ () const
{
  return this->START_FREQ_;
}

FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ ()
{
  return this->START_FREQ_;
}

void FREQUENCY::
START_FREQ (const START_FREQ_type& x)
{
  this->START_FREQ_.set (x);
}

void FREQUENCY::
START_FREQ (const START_FREQ_optional& x)
{
  this->START_FREQ_ = x;
}

void FREQUENCY::
START_FREQ (::std::auto_ptr< START_FREQ_type > x)
{
  this->START_FREQ_.set (x);
}

const FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ () const
{
  return this->END_FREQ_;
}

FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ ()
{
  return this->END_FREQ_;
}

void FREQUENCY::
END_FREQ (const END_FREQ_type& x)
{
  this->END_FREQ_.set (x);
}

void FREQUENCY::
END_FREQ (const END_FREQ_optional& x)
{
  this->END_FREQ_ = x;
}

void FREQUENCY::
END_FREQ (::std::auto_ptr< END_FREQ_type > x)
{
  this->END_FREQ_.set (x);
}

const FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ () const
{
  return this->STEP_FREQ_;
}

FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ ()
{
  return this->STEP_FREQ_;
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_type& x)
{
  this->STEP_FREQ_.set (x);
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_optional& x)
{
  this->STEP_FREQ_ = x;
}

void FREQUENCY::
STEP_FREQ (::std::auto_ptr< STEP_FREQ_type > x)
{
  this->STEP_FREQ_.set (x);
}

const FREQUENCY::Type_optional& FREQUENCY::
Type () const
{
  return this->Type_;
}

FREQUENCY::Type_optional& FREQUENCY::
Type ()
{
  return this->Type_;
}

void FREQUENCY::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FREQUENCY::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FREQUENCY::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// MATERIALS
// 

const MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL () const
{
  return this->MATERIAL_;
}

MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL ()
{
  return this->MATERIAL_;
}

void MATERIALS::
MATERIAL (const MATERIAL_sequence& s)
{
  this->MATERIAL_ = s;
}


// NODES
// 

const NODES::NODE_sequence& NODES::
NODE () const
{
  return this->NODE_;
}

NODES::NODE_sequence& NODES::
NODE ()
{
  return this->NODE_;
}

void NODES::
NODE (const NODE_sequence& s)
{
  this->NODE_ = s;
}


// ELEMENTS
// 

const ELEMENTS::ELEMENT_sequence& ELEMENTS::
ELEMENT () const
{
  return this->ELEMENT_;
}

ELEMENTS::ELEMENT_sequence& ELEMENTS::
ELEMENT ()
{
  return this->ELEMENT_;
}

void ELEMENTS::
ELEMENT (const ELEMENT_sequence& s)
{
  this->ELEMENT_ = s;
}


// LOADS
// 

const LOADS::LOAD_sequence& LOADS::
LOAD () const
{
  return this->LOAD_;
}

LOADS::LOAD_sequence& LOADS::
LOAD ()
{
  return this->LOAD_;
}

void LOADS::
LOAD (const LOAD_sequence& s)
{
  this->LOAD_ = s;
}


// BC
// 

const BC::DBC_sequence& BC::
DBC () const
{
  return this->DBC_;
}

BC::DBC_sequence& BC::
DBC ()
{
  return this->DBC_;
}

void BC::
DBC (const DBC_sequence& s)
{
  this->DBC_ = s;
}


// MATERIAL
// 

const MATERIAL::E_optional& MATERIAL::
E () const
{
  return this->E_;
}

MATERIAL::E_optional& MATERIAL::
E ()
{
  return this->E_;
}

void MATERIAL::
E (const E_type& x)
{
  this->E_.set (x);
}

void MATERIAL::
E (const E_optional& x)
{
  this->E_ = x;
}

void MATERIAL::
E (::std::auto_ptr< E_type > x)
{
  this->E_.set (x);
}

const MATERIAL::nu_optional& MATERIAL::
nu () const
{
  return this->nu_;
}

MATERIAL::nu_optional& MATERIAL::
nu ()
{
  return this->nu_;
}

void MATERIAL::
nu (const nu_type& x)
{
  this->nu_.set (x);
}

void MATERIAL::
nu (const nu_optional& x)
{
  this->nu_ = x;
}

void MATERIAL::
nu (::std::auto_ptr< nu_type > x)
{
  this->nu_.set (x);
}

const MATERIAL::rho_optional& MATERIAL::
rho () const
{
  return this->rho_;
}

MATERIAL::rho_optional& MATERIAL::
rho ()
{
  return this->rho_;
}

void MATERIAL::
rho (const rho_type& x)
{
  this->rho_.set (x);
}

void MATERIAL::
rho (const rho_optional& x)
{
  this->rho_ = x;
}

void MATERIAL::
rho (::std::auto_ptr< rho_type > x)
{
  this->rho_.set (x);
}

const MATERIAL::eta_optional& MATERIAL::
eta () const
{
  return this->eta_;
}

MATERIAL::eta_optional& MATERIAL::
eta ()
{
  return this->eta_;
}

void MATERIAL::
eta (const eta_type& x)
{
  this->eta_.set (x);
}

void MATERIAL::
eta (const eta_optional& x)
{
  this->eta_ = x;
}

void MATERIAL::
eta (::std::auto_ptr< eta_type > x)
{
  this->eta_.set (x);
}

const MATERIAL::Name_optional& MATERIAL::
Name () const
{
  return this->Name_;
}

MATERIAL::Name_optional& MATERIAL::
Name ()
{
  return this->Name_;
}

void MATERIAL::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void MATERIAL::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void MATERIAL::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const MATERIAL::Type_optional& MATERIAL::
Type () const
{
  return this->Type_;
}

MATERIAL::Type_optional& MATERIAL::
Type ()
{
  return this->Type_;
}

void MATERIAL::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void MATERIAL::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void MATERIAL::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// NODE
// 

const NODE::ID_optional& NODE::
ID () const
{
  return this->ID_;
}

NODE::ID_optional& NODE::
ID ()
{
  return this->ID_;
}

void NODE::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

void NODE::
ID (const ID_optional& x)
{
  this->ID_ = x;
}

void NODE::
ID (::std::auto_ptr< ID_type > x)
{
  this->ID_.set (x);
}

const NODE::X_optional& NODE::
X () const
{
  return this->X_;
}

NODE::X_optional& NODE::
X ()
{
  return this->X_;
}

void NODE::
X (const X_type& x)
{
  this->X_.set (x);
}

void NODE::
X (const X_optional& x)
{
  this->X_ = x;
}

void NODE::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const NODE::Y_optional& NODE::
Y () const
{
  return this->Y_;
}

NODE::Y_optional& NODE::
Y ()
{
  return this->Y_;
}

void NODE::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void NODE::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void NODE::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const NODE::Z_optional& NODE::
Z () const
{
  return this->Z_;
}

NODE::Z_optional& NODE::
Z ()
{
  return this->Z_;
}

void NODE::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void NODE::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void NODE::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// ELEMENT
// 

const ELEMENT::ID_optional& ELEMENT::
ID () const
{
  return this->ID_;
}

ELEMENT::ID_optional& ELEMENT::
ID ()
{
  return this->ID_;
}

void ELEMENT::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

void ELEMENT::
ID (const ID_optional& x)
{
  this->ID_ = x;
}

void ELEMENT::
ID (::std::auto_ptr< ID_type > x)
{
  this->ID_.set (x);
}

const ELEMENT::NODECONNECT_optional& ELEMENT::
NODECONNECT () const
{
  return this->NODECONNECT_;
}

ELEMENT::NODECONNECT_optional& ELEMENT::
NODECONNECT ()
{
  return this->NODECONNECT_;
}

void ELEMENT::
NODECONNECT (const NODECONNECT_type& x)
{
  this->NODECONNECT_.set (x);
}

void ELEMENT::
NODECONNECT (const NODECONNECT_optional& x)
{
  this->NODECONNECT_ = x;
}

void ELEMENT::
NODECONNECT (::std::auto_ptr< NODECONNECT_type > x)
{
  this->NODECONNECT_.set (x);
}

const ELEMENT::Type_optional& ELEMENT::
Type () const
{
  return this->Type_;
}

ELEMENT::Type_optional& ELEMENT::
Type ()
{
  return this->Type_;
}

void ELEMENT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void ELEMENT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void ELEMENT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const ELEMENT::MatID_optional& ELEMENT::
MatID () const
{
  return this->MatID_;
}

ELEMENT::MatID_optional& ELEMENT::
MatID ()
{
  return this->MatID_;
}

void ELEMENT::
MatID (const MatID_type& x)
{
  this->MatID_.set (x);
}

void ELEMENT::
MatID (const MatID_optional& x)
{
  this->MatID_ = x;
}

void ELEMENT::
MatID (::std::auto_ptr< MatID_type > x)
{
  this->MatID_.set (x);
}


// LOAD
// 

const LOAD::OnNode_optional& LOAD::
OnNode () const
{
  return this->OnNode_;
}

LOAD::OnNode_optional& LOAD::
OnNode ()
{
  return this->OnNode_;
}

void LOAD::
OnNode (const OnNode_type& x)
{
  this->OnNode_.set (x);
}

void LOAD::
OnNode (const OnNode_optional& x)
{
  this->OnNode_ = x;
}

void LOAD::
OnNode (::std::auto_ptr< OnNode_type > x)
{
  this->OnNode_.set (x);
}

const LOAD::Fx_optional& LOAD::
Fx () const
{
  return this->Fx_;
}

LOAD::Fx_optional& LOAD::
Fx ()
{
  return this->Fx_;
}

void LOAD::
Fx (const Fx_type& x)
{
  this->Fx_.set (x);
}

void LOAD::
Fx (const Fx_optional& x)
{
  this->Fx_ = x;
}

void LOAD::
Fx (::std::auto_ptr< Fx_type > x)
{
  this->Fx_.set (x);
}

const LOAD::iFx_optional& LOAD::
iFx () const
{
  return this->iFx_;
}

LOAD::iFx_optional& LOAD::
iFx ()
{
  return this->iFx_;
}

void LOAD::
iFx (const iFx_type& x)
{
  this->iFx_.set (x);
}

void LOAD::
iFx (const iFx_optional& x)
{
  this->iFx_ = x;
}

void LOAD::
iFx (::std::auto_ptr< iFx_type > x)
{
  this->iFx_.set (x);
}

const LOAD::Fy_optional& LOAD::
Fy () const
{
  return this->Fy_;
}

LOAD::Fy_optional& LOAD::
Fy ()
{
  return this->Fy_;
}

void LOAD::
Fy (const Fy_type& x)
{
  this->Fy_.set (x);
}

void LOAD::
Fy (const Fy_optional& x)
{
  this->Fy_ = x;
}

void LOAD::
Fy (::std::auto_ptr< Fy_type > x)
{
  this->Fy_.set (x);
}

const LOAD::iFy_optional& LOAD::
iFy () const
{
  return this->iFy_;
}

LOAD::iFy_optional& LOAD::
iFy ()
{
  return this->iFy_;
}

void LOAD::
iFy (const iFy_type& x)
{
  this->iFy_.set (x);
}

void LOAD::
iFy (const iFy_optional& x)
{
  this->iFy_ = x;
}

void LOAD::
iFy (::std::auto_ptr< iFy_type > x)
{
  this->iFy_.set (x);
}

const LOAD::Fz_optional& LOAD::
Fz () const
{
  return this->Fz_;
}

LOAD::Fz_optional& LOAD::
Fz ()
{
  return this->Fz_;
}

void LOAD::
Fz (const Fz_type& x)
{
  this->Fz_.set (x);
}

void LOAD::
Fz (const Fz_optional& x)
{
  this->Fz_ = x;
}

void LOAD::
Fz (::std::auto_ptr< Fz_type > x)
{
  this->Fz_.set (x);
}

const LOAD::iFz_optional& LOAD::
iFz () const
{
  return this->iFz_;
}

LOAD::iFz_optional& LOAD::
iFz ()
{
  return this->iFz_;
}

void LOAD::
iFz (const iFz_type& x)
{
  this->iFz_.set (x);
}

void LOAD::
iFz (const iFz_optional& x)
{
  this->iFz_ = x;
}

void LOAD::
iFz (::std::auto_ptr< iFz_type > x)
{
  this->iFz_.set (x);
}

const LOAD::Type_optional& LOAD::
Type () const
{
  return this->Type_;
}

LOAD::Type_optional& LOAD::
Type ()
{
  return this->Type_;
}

void LOAD::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void LOAD::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void LOAD::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// DBC
// 

const DBC::NODESET_optional& DBC::
NODESET () const
{
  return this->NODESET_;
}

DBC::NODESET_optional& DBC::
NODESET ()
{
  return this->NODESET_;
}

void DBC::
NODESET (const NODESET_type& x)
{
  this->NODESET_.set (x);
}

void DBC::
NODESET (const NODESET_optional& x)
{
  this->NODESET_ = x;
}

void DBC::
NODESET (::std::auto_ptr< NODESET_type > x)
{
  this->NODESET_.set (x);
}

const DBC::Ux_optional& DBC::
Ux () const
{
  return this->Ux_;
}

DBC::Ux_optional& DBC::
Ux ()
{
  return this->Ux_;
}

void DBC::
Ux (const Ux_type& x)
{
  this->Ux_.set (x);
}

void DBC::
Ux (const Ux_optional& x)
{
  this->Ux_ = x;
}

void DBC::
Ux (::std::auto_ptr< Ux_type > x)
{
  this->Ux_.set (x);
}

const DBC::Uy_optional& DBC::
Uy () const
{
  return this->Uy_;
}

DBC::Uy_optional& DBC::
Uy ()
{
  return this->Uy_;
}

void DBC::
Uy (const Uy_type& x)
{
  this->Uy_.set (x);
}

void DBC::
Uy (const Uy_optional& x)
{
  this->Uy_ = x;
}

void DBC::
Uy (::std::auto_ptr< Uy_type > x)
{
  this->Uy_.set (x);
}

const DBC::Uz_optional& DBC::
Uz () const
{
  return this->Uz_;
}

DBC::Uz_optional& DBC::
Uz ()
{
  return this->Uz_;
}

void DBC::
Uz (const Uz_type& x)
{
  this->Uz_.set (x);
}

void DBC::
Uz (const Uz_optional& x)
{
  this->Uz_ = x;
}

void DBC::
Uz (::std::auto_ptr< Uz_type > x)
{
  this->Uz_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// STACCATO_XML
//

STACCATO_XML::
STACCATO_XML ()
: ::xml_schema::type (),
  ANALYSIS_ (this),
  FREQUENCY_ (this),
  MATERIALS_ (this),
  NODES_ (this),
  ELEMENTS_ (this),
  LOADS_ (this),
  BC_ (this)
{
}

STACCATO_XML::
STACCATO_XML (const STACCATO_XML& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ANALYSIS_ (x.ANALYSIS_, f, this),
  FREQUENCY_ (x.FREQUENCY_, f, this),
  MATERIALS_ (x.MATERIALS_, f, this),
  NODES_ (x.NODES_, f, this),
  ELEMENTS_ (x.ELEMENTS_, f, this),
  LOADS_ (x.LOADS_, f, this),
  BC_ (x.BC_, f, this)
{
}

STACCATO_XML::
STACCATO_XML (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ANALYSIS_ (this),
  FREQUENCY_ (this),
  MATERIALS_ (this),
  NODES_ (this),
  ELEMENTS_ (this),
  LOADS_ (this),
  BC_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void STACCATO_XML::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ANALYSIS
    //
    if (n.name () == "ANALYSIS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ANALYSIS_type > r (
        ANALYSIS_traits::create (i, f, this));

      this->ANALYSIS_.push_back (r);
      continue;
    }

    // FREQUENCY
    //
    if (n.name () == "FREQUENCY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FREQUENCY_type > r (
        FREQUENCY_traits::create (i, f, this));

      this->FREQUENCY_.push_back (r);
      continue;
    }

    // MATERIALS
    //
    if (n.name () == "MATERIALS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIALS_type > r (
        MATERIALS_traits::create (i, f, this));

      this->MATERIALS_.push_back (r);
      continue;
    }

    // NODES
    //
    if (n.name () == "NODES" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODES_type > r (
        NODES_traits::create (i, f, this));

      this->NODES_.push_back (r);
      continue;
    }

    // ELEMENTS
    //
    if (n.name () == "ELEMENTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTS_type > r (
        ELEMENTS_traits::create (i, f, this));

      this->ELEMENTS_.push_back (r);
      continue;
    }

    // LOADS
    //
    if (n.name () == "LOADS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOADS_type > r (
        LOADS_traits::create (i, f, this));

      this->LOADS_.push_back (r);
      continue;
    }

    // BC
    //
    if (n.name () == "BC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BC_type > r (
        BC_traits::create (i, f, this));

      this->BC_.push_back (r);
      continue;
    }

    break;
  }
}

STACCATO_XML* STACCATO_XML::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class STACCATO_XML (*this, f, c);
}

STACCATO_XML& STACCATO_XML::
operator= (const STACCATO_XML& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ANALYSIS_ = x.ANALYSIS_;
    this->FREQUENCY_ = x.FREQUENCY_;
    this->MATERIALS_ = x.MATERIALS_;
    this->NODES_ = x.NODES_;
    this->ELEMENTS_ = x.ELEMENTS_;
    this->LOADS_ = x.LOADS_;
    this->BC_ = x.BC_;
  }

  return *this;
}

STACCATO_XML::
~STACCATO_XML ()
{
}

// ANALYSIS
//

ANALYSIS::
ANALYSIS ()
: ::xml_schema::type (),
  NAME_ (this),
  TYPE_ (this)
{
}

ANALYSIS::
ANALYSIS (const ANALYSIS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NAME_ (x.NAME_, f, this),
  TYPE_ (x.TYPE_, f, this)
{
}

ANALYSIS::
ANALYSIS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NAME_ (this),
  TYPE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ANALYSIS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NAME
    //
    if (n.name () == "NAME" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NAME_type > r (
        NAME_traits::create (i, f, this));

      if (!this->NAME_)
      {
        this->NAME_.set (r);
        continue;
      }
    }

    // TYPE
    //
    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TYPE_type > r (
        TYPE_traits::create (i, f, this));

      if (!this->TYPE_)
      {
        this->TYPE_.set (r);
        continue;
      }
    }

    break;
  }
}

ANALYSIS* ANALYSIS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ANALYSIS (*this, f, c);
}

ANALYSIS& ANALYSIS::
operator= (const ANALYSIS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NAME_ = x.NAME_;
    this->TYPE_ = x.TYPE_;
  }

  return *this;
}

ANALYSIS::
~ANALYSIS ()
{
}

// FREQUENCY
//

FREQUENCY::
FREQUENCY ()
: ::xml_schema::type (),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
}

FREQUENCY::
FREQUENCY (const FREQUENCY& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  START_FREQ_ (x.START_FREQ_, f, this),
  END_FREQ_ (x.END_FREQ_, f, this),
  STEP_FREQ_ (x.STEP_FREQ_, f, this),
  Type_ (x.Type_, f, this)
{
}

FREQUENCY::
FREQUENCY (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FREQUENCY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // START_FREQ
    //
    if (n.name () == "START_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< START_FREQ_type > r (
        START_FREQ_traits::create (i, f, this));

      if (!this->START_FREQ_)
      {
        this->START_FREQ_.set (r);
        continue;
      }
    }

    // END_FREQ
    //
    if (n.name () == "END_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< END_FREQ_type > r (
        END_FREQ_traits::create (i, f, this));

      if (!this->END_FREQ_)
      {
        this->END_FREQ_.set (r);
        continue;
      }
    }

    // STEP_FREQ
    //
    if (n.name () == "STEP_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< STEP_FREQ_type > r (
        STEP_FREQ_traits::create (i, f, this));

      if (!this->STEP_FREQ_)
      {
        this->STEP_FREQ_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FREQUENCY* FREQUENCY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FREQUENCY (*this, f, c);
}

FREQUENCY& FREQUENCY::
operator= (const FREQUENCY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->START_FREQ_ = x.START_FREQ_;
    this->END_FREQ_ = x.END_FREQ_;
    this->STEP_FREQ_ = x.STEP_FREQ_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FREQUENCY::
~FREQUENCY ()
{
}

// MATERIALS
//

MATERIALS::
MATERIALS ()
: ::xml_schema::type (),
  MATERIAL_ (this)
{
}

MATERIALS::
MATERIALS (const MATERIALS& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MATERIAL_ (x.MATERIAL_, f, this)
{
}

MATERIALS::
MATERIALS (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MATERIAL_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MATERIALS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MATERIAL
    //
    if (n.name () == "MATERIAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIAL_type > r (
        MATERIAL_traits::create (i, f, this));

      this->MATERIAL_.push_back (r);
      continue;
    }

    break;
  }
}

MATERIALS* MATERIALS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIALS (*this, f, c);
}

MATERIALS& MATERIALS::
operator= (const MATERIALS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MATERIAL_ = x.MATERIAL_;
  }

  return *this;
}

MATERIALS::
~MATERIALS ()
{
}

// NODES
//

NODES::
NODES ()
: ::xml_schema::type (),
  NODE_ (this)
{
}

NODES::
NODES (const NODES& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODE_ (x.NODE_, f, this)
{
}

NODES::
NODES (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NODES::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODE
    //
    if (n.name () == "NODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODE_type > r (
        NODE_traits::create (i, f, this));

      this->NODE_.push_back (r);
      continue;
    }

    break;
  }
}

NODES* NODES::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODES (*this, f, c);
}

NODES& NODES::
operator= (const NODES& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODE_ = x.NODE_;
  }

  return *this;
}

NODES::
~NODES ()
{
}

// ELEMENTS
//

ELEMENTS::
ELEMENTS ()
: ::xml_schema::type (),
  ELEMENT_ (this)
{
}

ELEMENTS::
ELEMENTS (const ELEMENTS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENT_ (x.ELEMENT_, f, this)
{
}

ELEMENTS::
ELEMENTS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ELEMENTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENT
    //
    if (n.name () == "ELEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENT_type > r (
        ELEMENT_traits::create (i, f, this));

      this->ELEMENT_.push_back (r);
      continue;
    }

    break;
  }
}

ELEMENTS* ELEMENTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENTS (*this, f, c);
}

ELEMENTS& ELEMENTS::
operator= (const ELEMENTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENT_ = x.ELEMENT_;
  }

  return *this;
}

ELEMENTS::
~ELEMENTS ()
{
}

// LOADS
//

LOADS::
LOADS ()
: ::xml_schema::type (),
  LOAD_ (this)
{
}

LOADS::
LOADS (const LOADS& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LOAD_ (x.LOAD_, f, this)
{
}

LOADS::
LOADS (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LOAD_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LOADS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LOAD
    //
    if (n.name () == "LOAD" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOAD_type > r (
        LOAD_traits::create (i, f, this));

      this->LOAD_.push_back (r);
      continue;
    }

    break;
  }
}

LOADS* LOADS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOADS (*this, f, c);
}

LOADS& LOADS::
operator= (const LOADS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LOAD_ = x.LOAD_;
  }

  return *this;
}

LOADS::
~LOADS ()
{
}

// BC
//

BC::
BC ()
: ::xml_schema::type (),
  DBC_ (this)
{
}

BC::
BC (const BC& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DBC_ (x.DBC_, f, this)
{
}

BC::
BC (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DBC_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BC::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DBC
    //
    if (n.name () == "DBC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DBC_type > r (
        DBC_traits::create (i, f, this));

      this->DBC_.push_back (r);
      continue;
    }

    break;
  }
}

BC* BC::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BC (*this, f, c);
}

BC& BC::
operator= (const BC& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DBC_ = x.DBC_;
  }

  return *this;
}

BC::
~BC ()
{
}

// MATERIAL
//

MATERIAL::
MATERIAL ()
: ::xml_schema::type (),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
}

MATERIAL::
MATERIAL (const MATERIAL& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  E_ (x.E_, f, this),
  nu_ (x.nu_, f, this),
  rho_ (x.rho_, f, this),
  eta_ (x.eta_, f, this),
  Name_ (x.Name_, f, this),
  Type_ (x.Type_, f, this)
{
}

MATERIAL::
MATERIAL (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MATERIAL::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // E
    //
    if (n.name () == "E" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< E_type > r (
        E_traits::create (i, f, this));

      if (!this->E_)
      {
        this->E_.set (r);
        continue;
      }
    }

    // nu
    //
    if (n.name () == "nu" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nu_type > r (
        nu_traits::create (i, f, this));

      if (!this->nu_)
      {
        this->nu_.set (r);
        continue;
      }
    }

    // rho
    //
    if (n.name () == "rho" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rho_type > r (
        rho_traits::create (i, f, this));

      if (!this->rho_)
      {
        this->rho_.set (r);
        continue;
      }
    }

    // eta
    //
    if (n.name () == "eta" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eta_type > r (
        eta_traits::create (i, f, this));

      if (!this->eta_)
      {
        this->eta_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

MATERIAL* MATERIAL::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIAL (*this, f, c);
}

MATERIAL& MATERIAL::
operator= (const MATERIAL& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->E_ = x.E_;
    this->nu_ = x.nu_;
    this->rho_ = x.rho_;
    this->eta_ = x.eta_;
    this->Name_ = x.Name_;
    this->Type_ = x.Type_;
  }

  return *this;
}

MATERIAL::
~MATERIAL ()
{
}

// NODE
//

NODE::
NODE ()
: ::xml_schema::type (),
  ID_ (this),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

NODE::
NODE (const NODE& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

NODE::
NODE (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NODE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID
    //
    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ID_type > r (
        ID_traits::create (i, f, this));

      if (!this->ID_)
      {
        this->ID_.set (r);
        continue;
      }
    }

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

NODE* NODE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODE (*this, f, c);
}

NODE& NODE::
operator= (const NODE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

NODE::
~NODE ()
{
}

// ELEMENT
//

ELEMENT::
ELEMENT ()
: ::xml_schema::type (),
  ID_ (this),
  NODECONNECT_ (this),
  Type_ (this),
  MatID_ (this)
{
}

ELEMENT::
ELEMENT (const ELEMENT& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ID_ (x.ID_, f, this),
  NODECONNECT_ (x.NODECONNECT_, f, this),
  Type_ (x.Type_, f, this),
  MatID_ (x.MatID_, f, this)
{
}

ELEMENT::
ELEMENT (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  NODECONNECT_ (this),
  Type_ (this),
  MatID_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ELEMENT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ID
    //
    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ID_type > r (
        ID_traits::create (i, f, this));

      if (!this->ID_)
      {
        this->ID_.set (r);
        continue;
      }
    }

    // NODECONNECT
    //
    if (n.name () == "NODECONNECT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODECONNECT_type > r (
        NODECONNECT_traits::create (i, f, this));

      if (!this->NODECONNECT_)
      {
        this->NODECONNECT_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "MatID" && n.namespace_ ().empty ())
    {
      this->MatID_.set (MatID_traits::create (i, f, this));
      continue;
    }
  }
}

ELEMENT* ELEMENT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENT (*this, f, c);
}

ELEMENT& ELEMENT::
operator= (const ELEMENT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ID_ = x.ID_;
    this->NODECONNECT_ = x.NODECONNECT_;
    this->Type_ = x.Type_;
    this->MatID_ = x.MatID_;
  }

  return *this;
}

ELEMENT::
~ELEMENT ()
{
}

// LOAD
//

LOAD::
LOAD ()
: ::xml_schema::type (),
  OnNode_ (this),
  Fx_ (this),
  iFx_ (this),
  Fy_ (this),
  iFy_ (this),
  Fz_ (this),
  iFz_ (this),
  Type_ (this)
{
}

LOAD::
LOAD (const LOAD& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  OnNode_ (x.OnNode_, f, this),
  Fx_ (x.Fx_, f, this),
  iFx_ (x.iFx_, f, this),
  Fy_ (x.Fy_, f, this),
  iFy_ (x.iFy_, f, this),
  Fz_ (x.Fz_, f, this),
  iFz_ (x.iFz_, f, this),
  Type_ (x.Type_, f, this)
{
}

LOAD::
LOAD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  OnNode_ (this),
  Fx_ (this),
  iFx_ (this),
  Fy_ (this),
  iFy_ (this),
  Fz_ (this),
  iFz_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void LOAD::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OnNode
    //
    if (n.name () == "OnNode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OnNode_type > r (
        OnNode_traits::create (i, f, this));

      if (!this->OnNode_)
      {
        this->OnNode_.set (r);
        continue;
      }
    }

    // Fx
    //
    if (n.name () == "Fx" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Fx_type > r (
        Fx_traits::create (i, f, this));

      if (!this->Fx_)
      {
        this->Fx_.set (r);
        continue;
      }
    }

    // iFx
    //
    if (n.name () == "iFx" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< iFx_type > r (
        iFx_traits::create (i, f, this));

      if (!this->iFx_)
      {
        this->iFx_.set (r);
        continue;
      }
    }

    // Fy
    //
    if (n.name () == "Fy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Fy_type > r (
        Fy_traits::create (i, f, this));

      if (!this->Fy_)
      {
        this->Fy_.set (r);
        continue;
      }
    }

    // iFy
    //
    if (n.name () == "iFy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< iFy_type > r (
        iFy_traits::create (i, f, this));

      if (!this->iFy_)
      {
        this->iFy_.set (r);
        continue;
      }
    }

    // Fz
    //
    if (n.name () == "Fz" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Fz_type > r (
        Fz_traits::create (i, f, this));

      if (!this->Fz_)
      {
        this->Fz_.set (r);
        continue;
      }
    }

    // iFz
    //
    if (n.name () == "iFz" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< iFz_type > r (
        iFz_traits::create (i, f, this));

      if (!this->iFz_)
      {
        this->iFz_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

LOAD* LOAD::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOAD (*this, f, c);
}

LOAD& LOAD::
operator= (const LOAD& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->OnNode_ = x.OnNode_;
    this->Fx_ = x.Fx_;
    this->iFx_ = x.iFx_;
    this->Fy_ = x.Fy_;
    this->iFy_ = x.iFy_;
    this->Fz_ = x.Fz_;
    this->iFz_ = x.iFz_;
    this->Type_ = x.Type_;
  }

  return *this;
}

LOAD::
~LOAD ()
{
}

// DBC
//

DBC::
DBC ()
: ::xml_schema::type (),
  NODESET_ (this),
  Ux_ (this),
  Uy_ (this),
  Uz_ (this)
{
}

DBC::
DBC (const DBC& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  Ux_ (x.Ux_, f, this),
  Uy_ (x.Uy_, f, this),
  Uz_ (x.Uz_, f, this)
{
}

DBC::
DBC (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  Ux_ (this),
  Uy_ (this),
  Uz_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DBC::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      if (!this->NODESET_)
      {
        this->NODESET_.set (r);
        continue;
      }
    }

    // Ux
    //
    if (n.name () == "Ux" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Ux_type > r (
        Ux_traits::create (i, f, this));

      if (!this->Ux_)
      {
        this->Ux_.set (r);
        continue;
      }
    }

    // Uy
    //
    if (n.name () == "Uy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Uy_type > r (
        Uy_traits::create (i, f, this));

      if (!this->Uy_)
      {
        this->Uy_.set (r);
        continue;
      }
    }

    // Uz
    //
    if (n.name () == "Uz" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Uz_type > r (
        Uz_traits::create (i, f, this));

      if (!this->Uz_)
      {
        this->Uz_.set (r);
        continue;
      }
    }

    break;
  }
}

DBC* DBC::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DBC (*this, f, c);
}

DBC& DBC::
operator= (const DBC& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->Ux_ = x.Ux_;
    this->Uy_ = x.Uy_;
    this->Uz_ = x.Uz_;
  }

  return *this;
}

DBC::
~DBC ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::STACCATO_XML > (
      ::STACCATO_XML_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

