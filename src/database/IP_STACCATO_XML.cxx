// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IP_STACCATO_XML.hxx"

// NODESET
// 

const NODESET::LIST_optional& NODESET::
LIST () const
{
  return this->LIST_;
}

NODESET::LIST_optional& NODESET::
LIST ()
{
  return this->LIST_;
}

void NODESET::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void NODESET::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void NODESET::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const NODESET::Name_optional& NODESET::
Name () const
{
  return this->Name_;
}

NODESET::Name_optional& NODESET::
Name ()
{
  return this->Name_;
}

void NODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void NODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void NODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const NODESET::Instance_optional& NODESET::
Instance () const
{
  return this->Instance_;
}

NODESET::Instance_optional& NODESET::
Instance ()
{
  return this->Instance_;
}

void NODESET::
Instance (const Instance_type& x)
{
  this->Instance_.set (x);
}

void NODESET::
Instance (const Instance_optional& x)
{
  this->Instance_ = x;
}

void NODESET::
Instance (::std::auto_ptr< Instance_type > x)
{
  this->Instance_.set (x);
}


// TRANSLATETO
// 

const TRANSLATETO::Source_optional& TRANSLATETO::
Source () const
{
  return this->Source_;
}

TRANSLATETO::Source_optional& TRANSLATETO::
Source ()
{
  return this->Source_;
}

void TRANSLATETO::
Source (const Source_type& x)
{
  this->Source_.set (x);
}

void TRANSLATETO::
Source (const Source_optional& x)
{
  this->Source_ = x;
}

void TRANSLATETO::
Source (::std::auto_ptr< Source_type > x)
{
  this->Source_.set (x);
}

const TRANSLATETO::Target_optional& TRANSLATETO::
Target () const
{
  return this->Target_;
}

TRANSLATETO::Target_optional& TRANSLATETO::
Target ()
{
  return this->Target_;
}

void TRANSLATETO::
Target (const Target_type& x)
{
  this->Target_.set (x);
}

void TRANSLATETO::
Target (const Target_optional& x)
{
  this->Target_ = x;
}

void TRANSLATETO::
Target (::std::auto_ptr< Target_type > x)
{
  this->Target_.set (x);
}


// LOAD
// 

const LOAD::NODESET_sequence& LOAD::
NODESET () const
{
  return this->NODESET_;
}

LOAD::NODESET_sequence& LOAD::
NODESET ()
{
  return this->NODESET_;
}

void LOAD::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const LOAD::REFERENCENODESET_sequence& LOAD::
REFERENCENODESET () const
{
  return this->REFERENCENODESET_;
}

LOAD::REFERENCENODESET_sequence& LOAD::
REFERENCENODESET ()
{
  return this->REFERENCENODESET_;
}

void LOAD::
REFERENCENODESET (const REFERENCENODESET_sequence& s)
{
  this->REFERENCENODESET_ = s;
}

const LOAD::REFERENCENODE_sequence& LOAD::
REFERENCENODE () const
{
  return this->REFERENCENODE_;
}

LOAD::REFERENCENODE_sequence& LOAD::
REFERENCENODE ()
{
  return this->REFERENCENODE_;
}

void LOAD::
REFERENCENODE (const REFERENCENODE_sequence& s)
{
  this->REFERENCENODE_ = s;
}

const LOAD::COUPLINGNODESET_sequence& LOAD::
COUPLINGNODESET () const
{
  return this->COUPLINGNODESET_;
}

LOAD::COUPLINGNODESET_sequence& LOAD::
COUPLINGNODESET ()
{
  return this->COUPLINGNODESET_;
}

void LOAD::
COUPLINGNODESET (const COUPLINGNODESET_sequence& s)
{
  this->COUPLINGNODESET_ = s;
}

const LOAD::REAL_sequence& LOAD::
REAL () const
{
  return this->REAL_;
}

LOAD::REAL_sequence& LOAD::
REAL ()
{
  return this->REAL_;
}

void LOAD::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const LOAD::IMAGINARY_sequence& LOAD::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

LOAD::IMAGINARY_sequence& LOAD::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void LOAD::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}

const LOAD::Type_optional& LOAD::
Type () const
{
  return this->Type_;
}

LOAD::Type_optional& LOAD::
Type ()
{
  return this->Type_;
}

void LOAD::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void LOAD::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void LOAD::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const LOAD::Name_optional& LOAD::
Name () const
{
  return this->Name_;
}

LOAD::Name_optional& LOAD::
Name ()
{
  return this->Name_;
}

void LOAD::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void LOAD::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void LOAD::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const LOAD::Instance_optional& LOAD::
Instance () const
{
  return this->Instance_;
}

LOAD::Instance_optional& LOAD::
Instance ()
{
  return this->Instance_;
}

void LOAD::
Instance (const Instance_type& x)
{
  this->Instance_.set (x);
}

void LOAD::
Instance (const Instance_optional& x)
{
  this->Instance_ = x;
}

void LOAD::
Instance (::std::auto_ptr< Instance_type > x)
{
  this->Instance_.set (x);
}


// REAL
// 

const REAL::X_optional& REAL::
X () const
{
  return this->X_;
}

REAL::X_optional& REAL::
X ()
{
  return this->X_;
}

void REAL::
X (const X_type& x)
{
  this->X_.set (x);
}

void REAL::
X (const X_optional& x)
{
  this->X_ = x;
}

void REAL::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const REAL::Y_optional& REAL::
Y () const
{
  return this->Y_;
}

REAL::Y_optional& REAL::
Y ()
{
  return this->Y_;
}

void REAL::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void REAL::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void REAL::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const REAL::Z_optional& REAL::
Z () const
{
  return this->Z_;
}

REAL::Z_optional& REAL::
Z ()
{
  return this->Z_;
}

void REAL::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void REAL::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void REAL::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// IMAGINARY
// 

const IMAGINARY::X_optional& IMAGINARY::
X () const
{
  return this->X_;
}

IMAGINARY::X_optional& IMAGINARY::
X ()
{
  return this->X_;
}

void IMAGINARY::
X (const X_type& x)
{
  this->X_.set (x);
}

void IMAGINARY::
X (const X_optional& x)
{
  this->X_ = x;
}

void IMAGINARY::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const IMAGINARY::Y_optional& IMAGINARY::
Y () const
{
  return this->Y_;
}

IMAGINARY::Y_optional& IMAGINARY::
Y ()
{
  return this->Y_;
}

void IMAGINARY::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void IMAGINARY::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void IMAGINARY::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const IMAGINARY::Z_optional& IMAGINARY::
Z () const
{
  return this->Z_;
}

IMAGINARY::Z_optional& IMAGINARY::
Z ()
{
  return this->Z_;
}

void IMAGINARY::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void IMAGINARY::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void IMAGINARY::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// STACCATO_XML
// 

const STACCATO_XML::NODESET_sequence& STACCATO_XML::
NODESET () const
{
  return this->NODESET_;
}

STACCATO_XML::NODESET_sequence& STACCATO_XML::
NODESET ()
{
  return this->NODESET_;
}

void STACCATO_XML::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const STACCATO_XML::TRANSLATETO_sequence& STACCATO_XML::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

STACCATO_XML::TRANSLATETO_sequence& STACCATO_XML::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void STACCATO_XML::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}

const STACCATO_XML::LOAD_sequence& STACCATO_XML::
LOAD () const
{
  return this->LOAD_;
}

STACCATO_XML::LOAD_sequence& STACCATO_XML::
LOAD ()
{
  return this->LOAD_;
}

void STACCATO_XML::
LOAD (const LOAD_sequence& s)
{
  this->LOAD_ = s;
}

const STACCATO_XML::REAL_sequence& STACCATO_XML::
REAL () const
{
  return this->REAL_;
}

STACCATO_XML::REAL_sequence& STACCATO_XML::
REAL ()
{
  return this->REAL_;
}

void STACCATO_XML::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const STACCATO_XML::IMAGINARY_sequence& STACCATO_XML::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

STACCATO_XML::IMAGINARY_sequence& STACCATO_XML::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void STACCATO_XML::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}

const STACCATO_XML::PARTS_sequence& STACCATO_XML::
PARTS () const
{
  return this->PARTS_;
}

STACCATO_XML::PARTS_sequence& STACCATO_XML::
PARTS ()
{
  return this->PARTS_;
}

void STACCATO_XML::
PARTS (const PARTS_sequence& s)
{
  this->PARTS_ = s;
}

const STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS () const
{
  return this->ANALYSIS_;
}

STACCATO_XML::ANALYSIS_sequence& STACCATO_XML::
ANALYSIS ()
{
  return this->ANALYSIS_;
}

void STACCATO_XML::
ANALYSIS (const ANALYSIS_sequence& s)
{
  this->ANALYSIS_ = s;
}


// REFERENCENODESET
// 

const REFERENCENODESET::Name_optional& REFERENCENODESET::
Name () const
{
  return this->Name_;
}

REFERENCENODESET::Name_optional& REFERENCENODESET::
Name ()
{
  return this->Name_;
}

void REFERENCENODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void REFERENCENODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void REFERENCENODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// REFERENCENODE
// 

const REFERENCENODE::X_optional& REFERENCENODE::
X () const
{
  return this->X_;
}

REFERENCENODE::X_optional& REFERENCENODE::
X ()
{
  return this->X_;
}

void REFERENCENODE::
X (const X_type& x)
{
  this->X_.set (x);
}

void REFERENCENODE::
X (const X_optional& x)
{
  this->X_ = x;
}

void REFERENCENODE::
X (::std::auto_ptr< X_type > x)
{
  this->X_.set (x);
}

const REFERENCENODE::Y_optional& REFERENCENODE::
Y () const
{
  return this->Y_;
}

REFERENCENODE::Y_optional& REFERENCENODE::
Y ()
{
  return this->Y_;
}

void REFERENCENODE::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void REFERENCENODE::
Y (const Y_optional& x)
{
  this->Y_ = x;
}

void REFERENCENODE::
Y (::std::auto_ptr< Y_type > x)
{
  this->Y_.set (x);
}

const REFERENCENODE::Z_optional& REFERENCENODE::
Z () const
{
  return this->Z_;
}

REFERENCENODE::Z_optional& REFERENCENODE::
Z ()
{
  return this->Z_;
}

void REFERENCENODE::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void REFERENCENODE::
Z (const Z_optional& x)
{
  this->Z_ = x;
}

void REFERENCENODE::
Z (::std::auto_ptr< Z_type > x)
{
  this->Z_.set (x);
}


// COUPLINGNODESET
// 

const COUPLINGNODESET::Name_optional& COUPLINGNODESET::
Name () const
{
  return this->Name_;
}

COUPLINGNODESET::Name_optional& COUPLINGNODESET::
Name ()
{
  return this->Name_;
}

void COUPLINGNODESET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void COUPLINGNODESET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void COUPLINGNODESET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// PARTS
// 

const PARTS::PART_sequence& PARTS::
PART () const
{
  return this->PART_;
}

PARTS::PART_sequence& PARTS::
PART ()
{
  return this->PART_;
}

void PARTS::
PART (const PART_sequence& s)
{
  this->PART_ = s;
}


// ANALYSIS
// 

const ANALYSIS::NAME_optional& ANALYSIS::
NAME () const
{
  return this->NAME_;
}

ANALYSIS::NAME_optional& ANALYSIS::
NAME ()
{
  return this->NAME_;
}

void ANALYSIS::
NAME (const NAME_type& x)
{
  this->NAME_.set (x);
}

void ANALYSIS::
NAME (const NAME_optional& x)
{
  this->NAME_ = x;
}

void ANALYSIS::
NAME (::std::auto_ptr< NAME_type > x)
{
  this->NAME_.set (x);
}

const ANALYSIS::TYPE_optional& ANALYSIS::
TYPE () const
{
  return this->TYPE_;
}

ANALYSIS::TYPE_optional& ANALYSIS::
TYPE ()
{
  return this->TYPE_;
}

void ANALYSIS::
TYPE (const TYPE_type& x)
{
  this->TYPE_.set (x);
}

void ANALYSIS::
TYPE (const TYPE_optional& x)
{
  this->TYPE_ = x;
}

void ANALYSIS::
TYPE (::std::auto_ptr< TYPE_type > x)
{
  this->TYPE_.set (x);
}

const ANALYSIS::FREQUENCY_sequence& ANALYSIS::
FREQUENCY () const
{
  return this->FREQUENCY_;
}

ANALYSIS::FREQUENCY_sequence& ANALYSIS::
FREQUENCY ()
{
  return this->FREQUENCY_;
}

void ANALYSIS::
FREQUENCY (const FREQUENCY_sequence& s)
{
  this->FREQUENCY_ = s;
}

const ANALYSIS::FILEEXPORT_sequence& ANALYSIS::
FILEEXPORT () const
{
  return this->FILEEXPORT_;
}

ANALYSIS::FILEEXPORT_sequence& ANALYSIS::
FILEEXPORT ()
{
  return this->FILEEXPORT_;
}

void ANALYSIS::
FILEEXPORT (const FILEEXPORT_sequence& s)
{
  this->FILEEXPORT_ = s;
}

const ANALYSIS::BCCASE_sequence& ANALYSIS::
BCCASE () const
{
  return this->BCCASE_;
}

ANALYSIS::BCCASE_sequence& ANALYSIS::
BCCASE ()
{
  return this->BCCASE_;
}

void ANALYSIS::
BCCASE (const BCCASE_sequence& s)
{
  this->BCCASE_ = s;
}

const ANALYSIS::LOADCASES_sequence& ANALYSIS::
LOADCASES () const
{
  return this->LOADCASES_;
}

ANALYSIS::LOADCASES_sequence& ANALYSIS::
LOADCASES ()
{
  return this->LOADCASES_;
}

void ANALYSIS::
LOADCASES (const LOADCASES_sequence& s)
{
  this->LOADCASES_ = s;
}


// PART
// 

const PART::ROMDATA_sequence& PART::
ROMDATA () const
{
  return this->ROMDATA_;
}

PART::ROMDATA_sequence& PART::
ROMDATA ()
{
  return this->ROMDATA_;
}

void PART::
ROMDATA (const ROMDATA_sequence& s)
{
  this->ROMDATA_ = s;
}

const PART::FILEIMPORT_sequence& PART::
FILEIMPORT () const
{
  return this->FILEIMPORT_;
}

PART::FILEIMPORT_sequence& PART::
FILEIMPORT ()
{
  return this->FILEIMPORT_;
}

void PART::
FILEIMPORT (const FILEIMPORT_sequence& s)
{
  this->FILEIMPORT_ = s;
}

const PART::MATERIALS_sequence& PART::
MATERIALS () const
{
  return this->MATERIALS_;
}

PART::MATERIALS_sequence& PART::
MATERIALS ()
{
  return this->MATERIALS_;
}

void PART::
MATERIALS (const MATERIALS_sequence& s)
{
  this->MATERIALS_ = s;
}

const PART::SECTIONS_sequence& PART::
SECTIONS () const
{
  return this->SECTIONS_;
}

PART::SECTIONS_sequence& PART::
SECTIONS ()
{
  return this->SECTIONS_;
}

void PART::
SECTIONS (const SECTIONS_sequence& s)
{
  this->SECTIONS_ = s;
}

const PART::SETS_sequence& PART::
SETS () const
{
  return this->SETS_;
}

PART::SETS_sequence& PART::
SETS ()
{
  return this->SETS_;
}

void PART::
SETS (const SETS_sequence& s)
{
  this->SETS_ = s;
}

const PART::LOADS_sequence& PART::
LOADS () const
{
  return this->LOADS_;
}

PART::LOADS_sequence& PART::
LOADS ()
{
  return this->LOADS_;
}

void PART::
LOADS (const LOADS_sequence& s)
{
  this->LOADS_ = s;
}

const PART::BC_DEF_sequence& PART::
BC_DEF () const
{
  return this->BC_DEF_;
}

PART::BC_DEF_sequence& PART::
BC_DEF ()
{
  return this->BC_DEF_;
}

void PART::
BC_DEF (const BC_DEF_sequence& s)
{
  this->BC_DEF_ = s;
}

const PART::TYPE_optional& PART::
TYPE () const
{
  return this->TYPE_;
}

PART::TYPE_optional& PART::
TYPE ()
{
  return this->TYPE_;
}

void PART::
TYPE (const TYPE_type& x)
{
  this->TYPE_.set (x);
}

void PART::
TYPE (const TYPE_optional& x)
{
  this->TYPE_ = x;
}

void PART::
TYPE (::std::auto_ptr< TYPE_type > x)
{
  this->TYPE_.set (x);
}

const PART::Name_optional& PART::
Name () const
{
  return this->Name_;
}

PART::Name_optional& PART::
Name ()
{
  return this->Name_;
}

void PART::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void PART::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void PART::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// FREQUENCY
// 

const FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ () const
{
  return this->START_FREQ_;
}

FREQUENCY::START_FREQ_optional& FREQUENCY::
START_FREQ ()
{
  return this->START_FREQ_;
}

void FREQUENCY::
START_FREQ (const START_FREQ_type& x)
{
  this->START_FREQ_.set (x);
}

void FREQUENCY::
START_FREQ (const START_FREQ_optional& x)
{
  this->START_FREQ_ = x;
}

void FREQUENCY::
START_FREQ (::std::auto_ptr< START_FREQ_type > x)
{
  this->START_FREQ_.set (x);
}

const FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ () const
{
  return this->END_FREQ_;
}

FREQUENCY::END_FREQ_optional& FREQUENCY::
END_FREQ ()
{
  return this->END_FREQ_;
}

void FREQUENCY::
END_FREQ (const END_FREQ_type& x)
{
  this->END_FREQ_.set (x);
}

void FREQUENCY::
END_FREQ (const END_FREQ_optional& x)
{
  this->END_FREQ_ = x;
}

void FREQUENCY::
END_FREQ (::std::auto_ptr< END_FREQ_type > x)
{
  this->END_FREQ_.set (x);
}

const FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ () const
{
  return this->STEP_FREQ_;
}

FREQUENCY::STEP_FREQ_optional& FREQUENCY::
STEP_FREQ ()
{
  return this->STEP_FREQ_;
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_type& x)
{
  this->STEP_FREQ_.set (x);
}

void FREQUENCY::
STEP_FREQ (const STEP_FREQ_optional& x)
{
  this->STEP_FREQ_ = x;
}

void FREQUENCY::
STEP_FREQ (::std::auto_ptr< STEP_FREQ_type > x)
{
  this->STEP_FREQ_.set (x);
}

const FREQUENCY::Type_optional& FREQUENCY::
Type () const
{
  return this->Type_;
}

FREQUENCY::Type_optional& FREQUENCY::
Type ()
{
  return this->Type_;
}

void FREQUENCY::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FREQUENCY::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FREQUENCY::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// FILEEXPORT
// 

const FILEEXPORT::EXPORT_sequence& FILEEXPORT::
EXPORT () const
{
  return this->EXPORT_;
}

FILEEXPORT::EXPORT_sequence& FILEEXPORT::
EXPORT ()
{
  return this->EXPORT_;
}

void FILEEXPORT::
EXPORT (const EXPORT_sequence& s)
{
  this->EXPORT_ = s;
}

const FILEEXPORT::Type_optional& FILEEXPORT::
Type () const
{
  return this->Type_;
}

FILEEXPORT::Type_optional& FILEEXPORT::
Type ()
{
  return this->Type_;
}

void FILEEXPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FILEEXPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FILEEXPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// BCCASE
// 

const BCCASE::BC_sequence& BCCASE::
BC () const
{
  return this->BC_;
}

BCCASE::BC_sequence& BCCASE::
BC ()
{
  return this->BC_;
}

void BCCASE::
BC (const BC_sequence& s)
{
  this->BC_ = s;
}

const BCCASE::Name_optional& BCCASE::
Name () const
{
  return this->Name_;
}

BCCASE::Name_optional& BCCASE::
Name ()
{
  return this->Name_;
}

void BCCASE::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void BCCASE::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void BCCASE::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// LOADCASES
// 

const LOADCASES::LOADCASE_sequence& LOADCASES::
LOADCASE () const
{
  return this->LOADCASE_;
}

LOADCASES::LOADCASE_sequence& LOADCASES::
LOADCASE ()
{
  return this->LOADCASE_;
}

void LOADCASES::
LOADCASE (const LOADCASE_sequence& s)
{
  this->LOADCASE_ = s;
}


// ROMDATA
// 

const ROMDATA::EXP_POINTS_sequence& ROMDATA::
EXP_POINTS () const
{
  return this->EXP_POINTS_;
}

ROMDATA::EXP_POINTS_sequence& ROMDATA::
EXP_POINTS ()
{
  return this->EXP_POINTS_;
}

void ROMDATA::
EXP_POINTS (const EXP_POINTS_sequence& s)
{
  this->EXP_POINTS_ = s;
}

const ROMDATA::KRYLOV_ORDER_sequence& ROMDATA::
KRYLOV_ORDER () const
{
  return this->KRYLOV_ORDER_;
}

ROMDATA::KRYLOV_ORDER_sequence& ROMDATA::
KRYLOV_ORDER ()
{
  return this->KRYLOV_ORDER_;
}

void ROMDATA::
KRYLOV_ORDER (const KRYLOV_ORDER_sequence& s)
{
  this->KRYLOV_ORDER_ = s;
}

const ROMDATA::INPUTS_sequence& ROMDATA::
INPUTS () const
{
  return this->INPUTS_;
}

ROMDATA::INPUTS_sequence& ROMDATA::
INPUTS ()
{
  return this->INPUTS_;
}

void ROMDATA::
INPUTS (const INPUTS_sequence& s)
{
  this->INPUTS_ = s;
}

const ROMDATA::OUTPUTS_sequence& ROMDATA::
OUTPUTS () const
{
  return this->OUTPUTS_;
}

ROMDATA::OUTPUTS_sequence& ROMDATA::
OUTPUTS ()
{
  return this->OUTPUTS_;
}

void ROMDATA::
OUTPUTS (const OUTPUTS_sequence& s)
{
  this->OUTPUTS_ = s;
}


// FILEIMPORT
// 

const FILEIMPORT::FILE_optional& FILEIMPORT::
FILE () const
{
  return this->FILE_;
}

FILEIMPORT::FILE_optional& FILEIMPORT::
FILE ()
{
  return this->FILE_;
}

void FILEIMPORT::
FILE (const FILE_type& x)
{
  this->FILE_.set (x);
}

void FILEIMPORT::
FILE (const FILE_optional& x)
{
  this->FILE_ = x;
}

void FILEIMPORT::
FILE (::std::auto_ptr< FILE_type > x)
{
  this->FILE_.set (x);
}

const FILEIMPORT::IMPORT_sequence& FILEIMPORT::
IMPORT () const
{
  return this->IMPORT_;
}

FILEIMPORT::IMPORT_sequence& FILEIMPORT::
IMPORT ()
{
  return this->IMPORT_;
}

void FILEIMPORT::
IMPORT (const IMPORT_sequence& s)
{
  this->IMPORT_ = s;
}

const FILEIMPORT::Type_optional& FILEIMPORT::
Type () const
{
  return this->Type_;
}

FILEIMPORT::Type_optional& FILEIMPORT::
Type ()
{
  return this->Type_;
}

void FILEIMPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void FILEIMPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void FILEIMPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// MATERIALS
// 

const MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL () const
{
  return this->MATERIAL_;
}

MATERIALS::MATERIAL_sequence& MATERIALS::
MATERIAL ()
{
  return this->MATERIAL_;
}

void MATERIALS::
MATERIAL (const MATERIAL_sequence& s)
{
  this->MATERIAL_ = s;
}


// SECTIONS
// 

const SECTIONS::SECTION_sequence& SECTIONS::
SECTION () const
{
  return this->SECTION_;
}

SECTIONS::SECTION_sequence& SECTIONS::
SECTION ()
{
  return this->SECTION_;
}

void SECTIONS::
SECTION (const SECTION_sequence& s)
{
  this->SECTION_ = s;
}


// SETS
// 

const SETS::ELEMENTSET_sequence& SETS::
ELEMENTSET () const
{
  return this->ELEMENTSET_;
}

SETS::ELEMENTSET_sequence& SETS::
ELEMENTSET ()
{
  return this->ELEMENTSET_;
}

void SETS::
ELEMENTSET (const ELEMENTSET_sequence& s)
{
  this->ELEMENTSET_ = s;
}

const SETS::NODESET_sequence& SETS::
NODESET () const
{
  return this->NODESET_;
}

SETS::NODESET_sequence& SETS::
NODESET ()
{
  return this->NODESET_;
}

void SETS::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}


// LOADS
// 

const LOADS::LOAD_sequence& LOADS::
LOAD () const
{
  return this->LOAD_;
}

LOADS::LOAD_sequence& LOADS::
LOAD ()
{
  return this->LOAD_;
}

void LOADS::
LOAD (const LOAD_sequence& s)
{
  this->LOAD_ = s;
}


// BC_DEF
// 

const BC_DEF::DISPLACEMENT_sequence& BC_DEF::
DISPLACEMENT () const
{
  return this->DISPLACEMENT_;
}

BC_DEF::DISPLACEMENT_sequence& BC_DEF::
DISPLACEMENT ()
{
  return this->DISPLACEMENT_;
}

void BC_DEF::
DISPLACEMENT (const DISPLACEMENT_sequence& s)
{
  this->DISPLACEMENT_ = s;
}


// EXPORT
// 

const EXPORT::INPUT_LOADCASE_sequence& EXPORT::
INPUT_LOADCASE () const
{
  return this->INPUT_LOADCASE_;
}

EXPORT::INPUT_LOADCASE_sequence& EXPORT::
INPUT_LOADCASE ()
{
  return this->INPUT_LOADCASE_;
}

void EXPORT::
INPUT_LOADCASE (const INPUT_LOADCASE_sequence& s)
{
  this->INPUT_LOADCASE_ = s;
}

const EXPORT::OUTPUTS_HISTORY_sequence& EXPORT::
OUTPUTS_HISTORY () const
{
  return this->OUTPUTS_HISTORY_;
}

EXPORT::OUTPUTS_HISTORY_sequence& EXPORT::
OUTPUTS_HISTORY ()
{
  return this->OUTPUTS_HISTORY_;
}

void EXPORT::
OUTPUTS_HISTORY (const OUTPUTS_HISTORY_sequence& s)
{
  this->OUTPUTS_HISTORY_ = s;
}

const EXPORT::Type_optional& EXPORT::
Type () const
{
  return this->Type_;
}

EXPORT::Type_optional& EXPORT::
Type ()
{
  return this->Type_;
}

void EXPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void EXPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void EXPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// BC
// 

const BC::Name_optional& BC::
Name () const
{
  return this->Name_;
}

BC::Name_optional& BC::
Name ()
{
  return this->Name_;
}

void BC::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void BC::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void BC::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const BC::Instance_optional& BC::
Instance () const
{
  return this->Instance_;
}

BC::Instance_optional& BC::
Instance ()
{
  return this->Instance_;
}

void BC::
Instance (const Instance_type& x)
{
  this->Instance_.set (x);
}

void BC::
Instance (const Instance_optional& x)
{
  this->Instance_ = x;
}

void BC::
Instance (::std::auto_ptr< Instance_type > x)
{
  this->Instance_.set (x);
}


// LOADCASE
// 

const LOADCASE::START_THETA_optional& LOADCASE::
START_THETA () const
{
  return this->START_THETA_;
}

LOADCASE::START_THETA_optional& LOADCASE::
START_THETA ()
{
  return this->START_THETA_;
}

void LOADCASE::
START_THETA (const START_THETA_type& x)
{
  this->START_THETA_.set (x);
}

void LOADCASE::
START_THETA (const START_THETA_optional& x)
{
  this->START_THETA_ = x;
}

void LOADCASE::
START_THETA (::std::auto_ptr< START_THETA_type > x)
{
  this->START_THETA_.set (x);
}

const LOADCASE::END_THETA_optional& LOADCASE::
END_THETA () const
{
  return this->END_THETA_;
}

LOADCASE::END_THETA_optional& LOADCASE::
END_THETA ()
{
  return this->END_THETA_;
}

void LOADCASE::
END_THETA (const END_THETA_type& x)
{
  this->END_THETA_.set (x);
}

void LOADCASE::
END_THETA (const END_THETA_optional& x)
{
  this->END_THETA_ = x;
}

void LOADCASE::
END_THETA (::std::auto_ptr< END_THETA_type > x)
{
  this->END_THETA_.set (x);
}

const LOADCASE::STEP_THETA_optional& LOADCASE::
STEP_THETA () const
{
  return this->STEP_THETA_;
}

LOADCASE::STEP_THETA_optional& LOADCASE::
STEP_THETA ()
{
  return this->STEP_THETA_;
}

void LOADCASE::
STEP_THETA (const STEP_THETA_type& x)
{
  this->STEP_THETA_.set (x);
}

void LOADCASE::
STEP_THETA (const STEP_THETA_optional& x)
{
  this->STEP_THETA_ = x;
}

void LOADCASE::
STEP_THETA (::std::auto_ptr< STEP_THETA_type > x)
{
  this->STEP_THETA_.set (x);
}

const LOADCASE::LOAD_sequence& LOADCASE::
LOAD () const
{
  return this->LOAD_;
}

LOADCASE::LOAD_sequence& LOADCASE::
LOAD ()
{
  return this->LOAD_;
}

void LOADCASE::
LOAD (const LOAD_sequence& s)
{
  this->LOAD_ = s;
}

const LOADCASE::Type_optional& LOADCASE::
Type () const
{
  return this->Type_;
}

LOADCASE::Type_optional& LOADCASE::
Type ()
{
  return this->Type_;
}

void LOADCASE::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void LOADCASE::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void LOADCASE::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}

const LOADCASE::NamePrefix_optional& LOADCASE::
NamePrefix () const
{
  return this->NamePrefix_;
}

LOADCASE::NamePrefix_optional& LOADCASE::
NamePrefix ()
{
  return this->NamePrefix_;
}

void LOADCASE::
NamePrefix (const NamePrefix_type& x)
{
  this->NamePrefix_.set (x);
}

void LOADCASE::
NamePrefix (const NamePrefix_optional& x)
{
  this->NamePrefix_ = x;
}

void LOADCASE::
NamePrefix (::std::auto_ptr< NamePrefix_type > x)
{
  this->NamePrefix_.set (x);
}


// EXP_POINTS
// 

const EXP_POINTS::Type_optional& EXP_POINTS::
Type () const
{
  return this->Type_;
}

EXP_POINTS::Type_optional& EXP_POINTS::
Type ()
{
  return this->Type_;
}

void EXP_POINTS::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void EXP_POINTS::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void EXP_POINTS::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// KRYLOV_ORDER
// 

const KRYLOV_ORDER::Type_optional& KRYLOV_ORDER::
Type () const
{
  return this->Type_;
}

KRYLOV_ORDER::Type_optional& KRYLOV_ORDER::
Type ()
{
  return this->Type_;
}

void KRYLOV_ORDER::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void KRYLOV_ORDER::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void KRYLOV_ORDER::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// INPUTS
// 

const INPUTS::NODESET_sequence& INPUTS::
NODESET () const
{
  return this->NODESET_;
}

INPUTS::NODESET_sequence& INPUTS::
NODESET ()
{
  return this->NODESET_;
}

void INPUTS::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const INPUTS::Type_optional& INPUTS::
Type () const
{
  return this->Type_;
}

INPUTS::Type_optional& INPUTS::
Type ()
{
  return this->Type_;
}

void INPUTS::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void INPUTS::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void INPUTS::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// OUTPUTS
// 

const OUTPUTS::Type_optional& OUTPUTS::
Type () const
{
  return this->Type_;
}

OUTPUTS::Type_optional& OUTPUTS::
Type ()
{
  return this->Type_;
}

void OUTPUTS::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void OUTPUTS::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void OUTPUTS::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// IMPORT
// 

const IMPORT::LIST_optional& IMPORT::
LIST () const
{
  return this->LIST_;
}

IMPORT::LIST_optional& IMPORT::
LIST ()
{
  return this->LIST_;
}

void IMPORT::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void IMPORT::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void IMPORT::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const IMPORT::UMA_sequence& IMPORT::
UMA () const
{
  return this->UMA_;
}

IMPORT::UMA_sequence& IMPORT::
UMA ()
{
  return this->UMA_;
}

void IMPORT::
UMA (const UMA_sequence& s)
{
  this->UMA_ = s;
}

const IMPORT::NODE_sequence& IMPORT::
NODE () const
{
  return this->NODE_;
}

IMPORT::NODE_sequence& IMPORT::
NODE ()
{
  return this->NODE_;
}

void IMPORT::
NODE (const NODE_sequence& s)
{
  this->NODE_ = s;
}

const IMPORT::ELEMENT_sequence& IMPORT::
ELEMENT () const
{
  return this->ELEMENT_;
}

IMPORT::ELEMENT_sequence& IMPORT::
ELEMENT ()
{
  return this->ELEMENT_;
}

void IMPORT::
ELEMENT (const ELEMENT_sequence& s)
{
  this->ELEMENT_ = s;
}

const IMPORT::TRANSLATETO_sequence& IMPORT::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

IMPORT::TRANSLATETO_sequence& IMPORT::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void IMPORT::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}

const IMPORT::Type_optional& IMPORT::
Type () const
{
  return this->Type_;
}

IMPORT::Type_optional& IMPORT::
Type ()
{
  return this->Type_;
}

void IMPORT::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void IMPORT::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void IMPORT::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// MATERIAL
// 

const MATERIAL::E_optional& MATERIAL::
E () const
{
  return this->E_;
}

MATERIAL::E_optional& MATERIAL::
E ()
{
  return this->E_;
}

void MATERIAL::
E (const E_type& x)
{
  this->E_.set (x);
}

void MATERIAL::
E (const E_optional& x)
{
  this->E_ = x;
}

void MATERIAL::
E (::std::auto_ptr< E_type > x)
{
  this->E_.set (x);
}

const MATERIAL::nu_optional& MATERIAL::
nu () const
{
  return this->nu_;
}

MATERIAL::nu_optional& MATERIAL::
nu ()
{
  return this->nu_;
}

void MATERIAL::
nu (const nu_type& x)
{
  this->nu_.set (x);
}

void MATERIAL::
nu (const nu_optional& x)
{
  this->nu_ = x;
}

void MATERIAL::
nu (::std::auto_ptr< nu_type > x)
{
  this->nu_.set (x);
}

const MATERIAL::rho_optional& MATERIAL::
rho () const
{
  return this->rho_;
}

MATERIAL::rho_optional& MATERIAL::
rho ()
{
  return this->rho_;
}

void MATERIAL::
rho (const rho_type& x)
{
  this->rho_.set (x);
}

void MATERIAL::
rho (const rho_optional& x)
{
  this->rho_ = x;
}

void MATERIAL::
rho (::std::auto_ptr< rho_type > x)
{
  this->rho_.set (x);
}

const MATERIAL::eta_optional& MATERIAL::
eta () const
{
  return this->eta_;
}

MATERIAL::eta_optional& MATERIAL::
eta ()
{
  return this->eta_;
}

void MATERIAL::
eta (const eta_type& x)
{
  this->eta_.set (x);
}

void MATERIAL::
eta (const eta_optional& x)
{
  this->eta_ = x;
}

void MATERIAL::
eta (::std::auto_ptr< eta_type > x)
{
  this->eta_.set (x);
}

const MATERIAL::Name_optional& MATERIAL::
Name () const
{
  return this->Name_;
}

MATERIAL::Name_optional& MATERIAL::
Name ()
{
  return this->Name_;
}

void MATERIAL::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void MATERIAL::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void MATERIAL::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}

const MATERIAL::Type_optional& MATERIAL::
Type () const
{
  return this->Type_;
}

MATERIAL::Type_optional& MATERIAL::
Type ()
{
  return this->Type_;
}

void MATERIAL::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void MATERIAL::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void MATERIAL::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// SECTION
// 

const SECTION::ELEMENTSET_optional& SECTION::
ELEMENTSET () const
{
  return this->ELEMENTSET_;
}

SECTION::ELEMENTSET_optional& SECTION::
ELEMENTSET ()
{
  return this->ELEMENTSET_;
}

void SECTION::
ELEMENTSET (const ELEMENTSET_type& x)
{
  this->ELEMENTSET_.set (x);
}

void SECTION::
ELEMENTSET (const ELEMENTSET_optional& x)
{
  this->ELEMENTSET_ = x;
}

void SECTION::
ELEMENTSET (::std::auto_ptr< ELEMENTSET_type > x)
{
  this->ELEMENTSET_.set (x);
}

const SECTION::MATERIAL_optional& SECTION::
MATERIAL () const
{
  return this->MATERIAL_;
}

SECTION::MATERIAL_optional& SECTION::
MATERIAL ()
{
  return this->MATERIAL_;
}

void SECTION::
MATERIAL (const MATERIAL_type& x)
{
  this->MATERIAL_.set (x);
}

void SECTION::
MATERIAL (const MATERIAL_optional& x)
{
  this->MATERIAL_ = x;
}

void SECTION::
MATERIAL (::std::auto_ptr< MATERIAL_type > x)
{
  this->MATERIAL_.set (x);
}

const SECTION::Name_optional& SECTION::
Name () const
{
  return this->Name_;
}

SECTION::Name_optional& SECTION::
Name ()
{
  return this->Name_;
}

void SECTION::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void SECTION::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void SECTION::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// ELEMENTSET
// 

const ELEMENTSET::LIST_optional& ELEMENTSET::
LIST () const
{
  return this->LIST_;
}

ELEMENTSET::LIST_optional& ELEMENTSET::
LIST ()
{
  return this->LIST_;
}

void ELEMENTSET::
LIST (const LIST_type& x)
{
  this->LIST_.set (x);
}

void ELEMENTSET::
LIST (const LIST_optional& x)
{
  this->LIST_ = x;
}

void ELEMENTSET::
LIST (::std::auto_ptr< LIST_type > x)
{
  this->LIST_.set (x);
}

const ELEMENTSET::Name_optional& ELEMENTSET::
Name () const
{
  return this->Name_;
}

ELEMENTSET::Name_optional& ELEMENTSET::
Name ()
{
  return this->Name_;
}

void ELEMENTSET::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void ELEMENTSET::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void ELEMENTSET::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// DISPLACEMENT
// 

const DISPLACEMENT::NODESET_sequence& DISPLACEMENT::
NODESET () const
{
  return this->NODESET_;
}

DISPLACEMENT::NODESET_sequence& DISPLACEMENT::
NODESET ()
{
  return this->NODESET_;
}

void DISPLACEMENT::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const DISPLACEMENT::REAL_sequence& DISPLACEMENT::
REAL () const
{
  return this->REAL_;
}

DISPLACEMENT::REAL_sequence& DISPLACEMENT::
REAL ()
{
  return this->REAL_;
}

void DISPLACEMENT::
REAL (const REAL_sequence& s)
{
  this->REAL_ = s;
}

const DISPLACEMENT::IMAGINARY_sequence& DISPLACEMENT::
IMAGINARY () const
{
  return this->IMAGINARY_;
}

DISPLACEMENT::IMAGINARY_sequence& DISPLACEMENT::
IMAGINARY ()
{
  return this->IMAGINARY_;
}

void DISPLACEMENT::
IMAGINARY (const IMAGINARY_sequence& s)
{
  this->IMAGINARY_ = s;
}

const DISPLACEMENT::Name_optional& DISPLACEMENT::
Name () const
{
  return this->Name_;
}

DISPLACEMENT::Name_optional& DISPLACEMENT::
Name ()
{
  return this->Name_;
}

void DISPLACEMENT::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DISPLACEMENT::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void DISPLACEMENT::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// INPUT_LOADCASE
// 

const INPUT_LOADCASE::NODESET_sequence& INPUT_LOADCASE::
NODESET () const
{
  return this->NODESET_;
}

INPUT_LOADCASE::NODESET_sequence& INPUT_LOADCASE::
NODESET ()
{
  return this->NODESET_;
}

void INPUT_LOADCASE::
NODESET (const NODESET_sequence& s)
{
  this->NODESET_ = s;
}

const INPUT_LOADCASE::Type_optional& INPUT_LOADCASE::
Type () const
{
  return this->Type_;
}

INPUT_LOADCASE::Type_optional& INPUT_LOADCASE::
Type ()
{
  return this->Type_;
}

void INPUT_LOADCASE::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void INPUT_LOADCASE::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void INPUT_LOADCASE::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// OUTPUTS_HISTORY
// 

const OUTPUTS_HISTORY::Type_optional& OUTPUTS_HISTORY::
Type () const
{
  return this->Type_;
}

OUTPUTS_HISTORY::Type_optional& OUTPUTS_HISTORY::
Type ()
{
  return this->Type_;
}

void OUTPUTS_HISTORY::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void OUTPUTS_HISTORY::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void OUTPUTS_HISTORY::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// UMA
// 

const UMA::Type_optional& UMA::
Type () const
{
  return this->Type_;
}

UMA::Type_optional& UMA::
Type ()
{
  return this->Type_;
}

void UMA::
Type (const Type_type& x)
{
  this->Type_.set (x);
}

void UMA::
Type (const Type_optional& x)
{
  this->Type_ = x;
}

void UMA::
Type (::std::auto_ptr< Type_type > x)
{
  this->Type_.set (x);
}


// NODE
// 

const NODE::TRANSLATETO_sequence& NODE::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

NODE::TRANSLATETO_sequence& NODE::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void NODE::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}


// ELEMENT
// 

const ELEMENT::TRANSLATETO_sequence& ELEMENT::
TRANSLATETO () const
{
  return this->TRANSLATETO_;
}

ELEMENT::TRANSLATETO_sequence& ELEMENT::
TRANSLATETO ()
{
  return this->TRANSLATETO_;
}

void ELEMENT::
TRANSLATETO (const TRANSLATETO_sequence& s)
{
  this->TRANSLATETO_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// NODESET
//

NODESET::
NODESET ()
: ::xml_schema::type (),
  LIST_ (this),
  Name_ (this),
  Instance_ (this)
{
}

NODESET::
NODESET (const NODESET& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  Name_ (x.Name_, f, this),
  Instance_ (x.Instance_, f, this)
{
}

NODESET::
NODESET (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  Name_ (this),
  Instance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void NODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Instance" && n.namespace_ ().empty ())
    {
      this->Instance_.set (Instance_traits::create (i, f, this));
      continue;
    }
  }
}

NODESET* NODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODESET (*this, f, c);
}

NODESET& NODESET::
operator= (const NODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->Name_ = x.Name_;
    this->Instance_ = x.Instance_;
  }

  return *this;
}

NODESET::
~NODESET ()
{
}

// TRANSLATETO
//

TRANSLATETO::
TRANSLATETO ()
: ::xml_schema::type (),
  Source_ (this),
  Target_ (this)
{
}

TRANSLATETO::
TRANSLATETO (const TRANSLATETO& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Source_ (x.Source_, f, this),
  Target_ (x.Target_, f, this)
{
}

TRANSLATETO::
TRANSLATETO (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Source_ (this),
  Target_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void TRANSLATETO::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Source" && n.namespace_ ().empty ())
    {
      this->Source_.set (Source_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Target" && n.namespace_ ().empty ())
    {
      this->Target_.set (Target_traits::create (i, f, this));
      continue;
    }
  }
}

TRANSLATETO* TRANSLATETO::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TRANSLATETO (*this, f, c);
}

TRANSLATETO& TRANSLATETO::
operator= (const TRANSLATETO& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Source_ = x.Source_;
    this->Target_ = x.Target_;
  }

  return *this;
}

TRANSLATETO::
~TRANSLATETO ()
{
}

// LOAD
//

LOAD::
LOAD ()
: ::xml_schema::type (),
  NODESET_ (this),
  REFERENCENODESET_ (this),
  REFERENCENODE_ (this),
  COUPLINGNODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Type_ (this),
  Name_ (this),
  Instance_ (this)
{
}

LOAD::
LOAD (const LOAD& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  REFERENCENODESET_ (x.REFERENCENODESET_, f, this),
  REFERENCENODE_ (x.REFERENCENODE_, f, this),
  COUPLINGNODESET_ (x.COUPLINGNODESET_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this),
  Type_ (x.Type_, f, this),
  Name_ (x.Name_, f, this),
  Instance_ (x.Instance_, f, this)
{
}

LOAD::
LOAD (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  REFERENCENODESET_ (this),
  REFERENCENODE_ (this),
  COUPLINGNODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Type_ (this),
  Name_ (this),
  Instance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void LOAD::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // REFERENCENODESET
    //
    if (n.name () == "REFERENCENODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REFERENCENODESET_type > r (
        REFERENCENODESET_traits::create (i, f, this));

      this->REFERENCENODESET_.push_back (r);
      continue;
    }

    // REFERENCENODE
    //
    if (n.name () == "REFERENCENODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REFERENCENODE_type > r (
        REFERENCENODE_traits::create (i, f, this));

      this->REFERENCENODE_.push_back (r);
      continue;
    }

    // COUPLINGNODESET
    //
    if (n.name () == "COUPLINGNODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< COUPLINGNODESET_type > r (
        COUPLINGNODESET_traits::create (i, f, this));

      this->COUPLINGNODESET_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Instance" && n.namespace_ ().empty ())
    {
      this->Instance_.set (Instance_traits::create (i, f, this));
      continue;
    }
  }
}

LOAD* LOAD::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOAD (*this, f, c);
}

LOAD& LOAD::
operator= (const LOAD& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->REFERENCENODESET_ = x.REFERENCENODESET_;
    this->REFERENCENODE_ = x.REFERENCENODE_;
    this->COUPLINGNODESET_ = x.COUPLINGNODESET_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
    this->Type_ = x.Type_;
    this->Name_ = x.Name_;
    this->Instance_ = x.Instance_;
  }

  return *this;
}

LOAD::
~LOAD ()
{
}

// REAL
//

REAL::
REAL ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

REAL::
REAL (const REAL& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

REAL::
REAL (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void REAL::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

REAL* REAL::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REAL (*this, f, c);
}

REAL& REAL::
operator= (const REAL& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

REAL::
~REAL ()
{
}

// IMAGINARY
//

IMAGINARY::
IMAGINARY ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

IMAGINARY::
IMAGINARY (const IMAGINARY& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

IMAGINARY::
IMAGINARY (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void IMAGINARY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

IMAGINARY* IMAGINARY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IMAGINARY (*this, f, c);
}

IMAGINARY& IMAGINARY::
operator= (const IMAGINARY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

IMAGINARY::
~IMAGINARY ()
{
}

// STACCATO_XML
//

STACCATO_XML::
STACCATO_XML ()
: ::xml_schema::type (),
  NODESET_ (this),
  TRANSLATETO_ (this),
  LOAD_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  PARTS_ (this),
  ANALYSIS_ (this)
{
}

STACCATO_XML::
STACCATO_XML (const STACCATO_XML& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this),
  LOAD_ (x.LOAD_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this),
  PARTS_ (x.PARTS_, f, this),
  ANALYSIS_ (x.ANALYSIS_, f, this)
{
}

STACCATO_XML::
STACCATO_XML (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  TRANSLATETO_ (this),
  LOAD_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  PARTS_ (this),
  ANALYSIS_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void STACCATO_XML::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    // LOAD
    //
    if (n.name () == "LOAD" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOAD_type > r (
        LOAD_traits::create (i, f, this));

      this->LOAD_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    // PARTS
    //
    if (n.name () == "PARTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PARTS_type > r (
        PARTS_traits::create (i, f, this));

      this->PARTS_.push_back (r);
      continue;
    }

    // ANALYSIS
    //
    if (n.name () == "ANALYSIS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ANALYSIS_type > r (
        ANALYSIS_traits::create (i, f, this));

      this->ANALYSIS_.push_back (r);
      continue;
    }

    break;
  }
}

STACCATO_XML* STACCATO_XML::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class STACCATO_XML (*this, f, c);
}

STACCATO_XML& STACCATO_XML::
operator= (const STACCATO_XML& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
    this->LOAD_ = x.LOAD_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
    this->PARTS_ = x.PARTS_;
    this->ANALYSIS_ = x.ANALYSIS_;
  }

  return *this;
}

STACCATO_XML::
~STACCATO_XML ()
{
}

// REFERENCENODESET
//

REFERENCENODESET::
REFERENCENODESET ()
: ::xml_schema::type (),
  Name_ (this)
{
}

REFERENCENODESET::
REFERENCENODESET (const REFERENCENODESET& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

REFERENCENODESET::
REFERENCENODESET (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void REFERENCENODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

REFERENCENODESET* REFERENCENODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REFERENCENODESET (*this, f, c);
}

REFERENCENODESET& REFERENCENODESET::
operator= (const REFERENCENODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

REFERENCENODESET::
~REFERENCENODESET ()
{
}

// REFERENCENODE
//

REFERENCENODE::
REFERENCENODE ()
: ::xml_schema::type (),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
}

REFERENCENODE::
REFERENCENODE (const REFERENCENODE& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

REFERENCENODE::
REFERENCENODE (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void REFERENCENODE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< X_type > r (
        X_traits::create (i, f, this));

      if (!this->X_)
      {
        this->X_.set (r);
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Y_type > r (
        Y_traits::create (i, f, this));

      if (!this->Y_)
      {
        this->Y_.set (r);
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Z_type > r (
        Z_traits::create (i, f, this));

      if (!this->Z_)
      {
        this->Z_.set (r);
        continue;
      }
    }

    break;
  }
}

REFERENCENODE* REFERENCENODE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class REFERENCENODE (*this, f, c);
}

REFERENCENODE& REFERENCENODE::
operator= (const REFERENCENODE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

REFERENCENODE::
~REFERENCENODE ()
{
}

// COUPLINGNODESET
//

COUPLINGNODESET::
COUPLINGNODESET ()
: ::xml_schema::type (),
  Name_ (this)
{
}

COUPLINGNODESET::
COUPLINGNODESET (const COUPLINGNODESET& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

COUPLINGNODESET::
COUPLINGNODESET (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void COUPLINGNODESET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

COUPLINGNODESET* COUPLINGNODESET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class COUPLINGNODESET (*this, f, c);
}

COUPLINGNODESET& COUPLINGNODESET::
operator= (const COUPLINGNODESET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

COUPLINGNODESET::
~COUPLINGNODESET ()
{
}

// PARTS
//

PARTS::
PARTS ()
: ::xml_schema::type (),
  PART_ (this)
{
}

PARTS::
PARTS (const PARTS& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  PART_ (x.PART_, f, this)
{
}

PARTS::
PARTS (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  PART_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PARTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // PART
    //
    if (n.name () == "PART" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< PART_type > r (
        PART_traits::create (i, f, this));

      this->PART_.push_back (r);
      continue;
    }

    break;
  }
}

PARTS* PARTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PARTS (*this, f, c);
}

PARTS& PARTS::
operator= (const PARTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->PART_ = x.PART_;
  }

  return *this;
}

PARTS::
~PARTS ()
{
}

// ANALYSIS
//

ANALYSIS::
ANALYSIS ()
: ::xml_schema::type (),
  NAME_ (this),
  TYPE_ (this),
  FREQUENCY_ (this),
  FILEEXPORT_ (this),
  BCCASE_ (this),
  LOADCASES_ (this)
{
}

ANALYSIS::
ANALYSIS (const ANALYSIS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NAME_ (x.NAME_, f, this),
  TYPE_ (x.TYPE_, f, this),
  FREQUENCY_ (x.FREQUENCY_, f, this),
  FILEEXPORT_ (x.FILEEXPORT_, f, this),
  BCCASE_ (x.BCCASE_, f, this),
  LOADCASES_ (x.LOADCASES_, f, this)
{
}

ANALYSIS::
ANALYSIS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NAME_ (this),
  TYPE_ (this),
  FREQUENCY_ (this),
  FILEEXPORT_ (this),
  BCCASE_ (this),
  LOADCASES_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ANALYSIS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NAME
    //
    if (n.name () == "NAME" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NAME_type > r (
        NAME_traits::create (i, f, this));

      if (!this->NAME_)
      {
        this->NAME_.set (r);
        continue;
      }
    }

    // TYPE
    //
    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TYPE_type > r (
        TYPE_traits::create (i, f, this));

      if (!this->TYPE_)
      {
        this->TYPE_.set (r);
        continue;
      }
    }

    // FREQUENCY
    //
    if (n.name () == "FREQUENCY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FREQUENCY_type > r (
        FREQUENCY_traits::create (i, f, this));

      this->FREQUENCY_.push_back (r);
      continue;
    }

    // FILEEXPORT
    //
    if (n.name () == "FILEEXPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILEEXPORT_type > r (
        FILEEXPORT_traits::create (i, f, this));

      this->FILEEXPORT_.push_back (r);
      continue;
    }

    // BCCASE
    //
    if (n.name () == "BCCASE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BCCASE_type > r (
        BCCASE_traits::create (i, f, this));

      this->BCCASE_.push_back (r);
      continue;
    }

    // LOADCASES
    //
    if (n.name () == "LOADCASES" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOADCASES_type > r (
        LOADCASES_traits::create (i, f, this));

      this->LOADCASES_.push_back (r);
      continue;
    }

    break;
  }
}

ANALYSIS* ANALYSIS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ANALYSIS (*this, f, c);
}

ANALYSIS& ANALYSIS::
operator= (const ANALYSIS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NAME_ = x.NAME_;
    this->TYPE_ = x.TYPE_;
    this->FREQUENCY_ = x.FREQUENCY_;
    this->FILEEXPORT_ = x.FILEEXPORT_;
    this->BCCASE_ = x.BCCASE_;
    this->LOADCASES_ = x.LOADCASES_;
  }

  return *this;
}

ANALYSIS::
~ANALYSIS ()
{
}

// PART
//

PART::
PART ()
: ::xml_schema::type (),
  ROMDATA_ (this),
  FILEIMPORT_ (this),
  MATERIALS_ (this),
  SECTIONS_ (this),
  SETS_ (this),
  LOADS_ (this),
  BC_DEF_ (this),
  TYPE_ (this),
  Name_ (this)
{
}

PART::
PART (const PART& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ROMDATA_ (x.ROMDATA_, f, this),
  FILEIMPORT_ (x.FILEIMPORT_, f, this),
  MATERIALS_ (x.MATERIALS_, f, this),
  SECTIONS_ (x.SECTIONS_, f, this),
  SETS_ (x.SETS_, f, this),
  LOADS_ (x.LOADS_, f, this),
  BC_DEF_ (x.BC_DEF_, f, this),
  TYPE_ (x.TYPE_, f, this),
  Name_ (x.Name_, f, this)
{
}

PART::
PART (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ROMDATA_ (this),
  FILEIMPORT_ (this),
  MATERIALS_ (this),
  SECTIONS_ (this),
  SETS_ (this),
  LOADS_ (this),
  BC_DEF_ (this),
  TYPE_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void PART::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ROMDATA
    //
    if (n.name () == "ROMDATA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ROMDATA_type > r (
        ROMDATA_traits::create (i, f, this));

      this->ROMDATA_.push_back (r);
      continue;
    }

    // FILEIMPORT
    //
    if (n.name () == "FILEIMPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILEIMPORT_type > r (
        FILEIMPORT_traits::create (i, f, this));

      this->FILEIMPORT_.push_back (r);
      continue;
    }

    // MATERIALS
    //
    if (n.name () == "MATERIALS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIALS_type > r (
        MATERIALS_traits::create (i, f, this));

      this->MATERIALS_.push_back (r);
      continue;
    }

    // SECTIONS
    //
    if (n.name () == "SECTIONS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SECTIONS_type > r (
        SECTIONS_traits::create (i, f, this));

      this->SECTIONS_.push_back (r);
      continue;
    }

    // SETS
    //
    if (n.name () == "SETS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SETS_type > r (
        SETS_traits::create (i, f, this));

      this->SETS_.push_back (r);
      continue;
    }

    // LOADS
    //
    if (n.name () == "LOADS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOADS_type > r (
        LOADS_traits::create (i, f, this));

      this->LOADS_.push_back (r);
      continue;
    }

    // BC_DEF
    //
    if (n.name () == "BC_DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BC_DEF_type > r (
        BC_DEF_traits::create (i, f, this));

      this->BC_DEF_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "TYPE" && n.namespace_ ().empty ())
    {
      this->TYPE_.set (TYPE_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

PART* PART::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PART (*this, f, c);
}

PART& PART::
operator= (const PART& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ROMDATA_ = x.ROMDATA_;
    this->FILEIMPORT_ = x.FILEIMPORT_;
    this->MATERIALS_ = x.MATERIALS_;
    this->SECTIONS_ = x.SECTIONS_;
    this->SETS_ = x.SETS_;
    this->LOADS_ = x.LOADS_;
    this->BC_DEF_ = x.BC_DEF_;
    this->TYPE_ = x.TYPE_;
    this->Name_ = x.Name_;
  }

  return *this;
}

PART::
~PART ()
{
}

// FREQUENCY
//

FREQUENCY::
FREQUENCY ()
: ::xml_schema::type (),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
}

FREQUENCY::
FREQUENCY (const FREQUENCY& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  START_FREQ_ (x.START_FREQ_, f, this),
  END_FREQ_ (x.END_FREQ_, f, this),
  STEP_FREQ_ (x.STEP_FREQ_, f, this),
  Type_ (x.Type_, f, this)
{
}

FREQUENCY::
FREQUENCY (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  START_FREQ_ (this),
  END_FREQ_ (this),
  STEP_FREQ_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FREQUENCY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // START_FREQ
    //
    if (n.name () == "START_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< START_FREQ_type > r (
        START_FREQ_traits::create (i, f, this));

      if (!this->START_FREQ_)
      {
        this->START_FREQ_.set (r);
        continue;
      }
    }

    // END_FREQ
    //
    if (n.name () == "END_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< END_FREQ_type > r (
        END_FREQ_traits::create (i, f, this));

      if (!this->END_FREQ_)
      {
        this->END_FREQ_.set (r);
        continue;
      }
    }

    // STEP_FREQ
    //
    if (n.name () == "STEP_FREQ" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< STEP_FREQ_type > r (
        STEP_FREQ_traits::create (i, f, this));

      if (!this->STEP_FREQ_)
      {
        this->STEP_FREQ_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FREQUENCY* FREQUENCY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FREQUENCY (*this, f, c);
}

FREQUENCY& FREQUENCY::
operator= (const FREQUENCY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->START_FREQ_ = x.START_FREQ_;
    this->END_FREQ_ = x.END_FREQ_;
    this->STEP_FREQ_ = x.STEP_FREQ_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FREQUENCY::
~FREQUENCY ()
{
}

// FILEEXPORT
//

FILEEXPORT::
FILEEXPORT ()
: ::xml_schema::type (),
  EXPORT_ (this),
  Type_ (this)
{
}

FILEEXPORT::
FILEEXPORT (const FILEEXPORT& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  EXPORT_ (x.EXPORT_, f, this),
  Type_ (x.Type_, f, this)
{
}

FILEEXPORT::
FILEEXPORT (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  EXPORT_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FILEEXPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // EXPORT
    //
    if (n.name () == "EXPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EXPORT_type > r (
        EXPORT_traits::create (i, f, this));

      this->EXPORT_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FILEEXPORT* FILEEXPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FILEEXPORT (*this, f, c);
}

FILEEXPORT& FILEEXPORT::
operator= (const FILEEXPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->EXPORT_ = x.EXPORT_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FILEEXPORT::
~FILEEXPORT ()
{
}

// BCCASE
//

BCCASE::
BCCASE ()
: ::xml_schema::type (),
  BC_ (this),
  Name_ (this)
{
}

BCCASE::
BCCASE (const BCCASE& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BC_ (x.BC_, f, this),
  Name_ (x.Name_, f, this)
{
}

BCCASE::
BCCASE (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BC_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void BCCASE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BC
    //
    if (n.name () == "BC" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< BC_type > r (
        BC_traits::create (i, f, this));

      this->BC_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

BCCASE* BCCASE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BCCASE (*this, f, c);
}

BCCASE& BCCASE::
operator= (const BCCASE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BC_ = x.BC_;
    this->Name_ = x.Name_;
  }

  return *this;
}

BCCASE::
~BCCASE ()
{
}

// LOADCASES
//

LOADCASES::
LOADCASES ()
: ::xml_schema::type (),
  LOADCASE_ (this)
{
}

LOADCASES::
LOADCASES (const LOADCASES& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LOADCASE_ (x.LOADCASE_, f, this)
{
}

LOADCASES::
LOADCASES (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LOADCASE_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LOADCASES::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LOADCASE
    //
    if (n.name () == "LOADCASE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOADCASE_type > r (
        LOADCASE_traits::create (i, f, this));

      this->LOADCASE_.push_back (r);
      continue;
    }

    break;
  }
}

LOADCASES* LOADCASES::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOADCASES (*this, f, c);
}

LOADCASES& LOADCASES::
operator= (const LOADCASES& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LOADCASE_ = x.LOADCASE_;
  }

  return *this;
}

LOADCASES::
~LOADCASES ()
{
}

// ROMDATA
//

ROMDATA::
ROMDATA ()
: ::xml_schema::type (),
  EXP_POINTS_ (this),
  KRYLOV_ORDER_ (this),
  INPUTS_ (this),
  OUTPUTS_ (this)
{
}

ROMDATA::
ROMDATA (const ROMDATA& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  EXP_POINTS_ (x.EXP_POINTS_, f, this),
  KRYLOV_ORDER_ (x.KRYLOV_ORDER_, f, this),
  INPUTS_ (x.INPUTS_, f, this),
  OUTPUTS_ (x.OUTPUTS_, f, this)
{
}

ROMDATA::
ROMDATA (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  EXP_POINTS_ (this),
  KRYLOV_ORDER_ (this),
  INPUTS_ (this),
  OUTPUTS_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ROMDATA::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // EXP_POINTS
    //
    if (n.name () == "EXP_POINTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< EXP_POINTS_type > r (
        EXP_POINTS_traits::create (i, f, this));

      this->EXP_POINTS_.push_back (r);
      continue;
    }

    // KRYLOV_ORDER
    //
    if (n.name () == "KRYLOV_ORDER" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< KRYLOV_ORDER_type > r (
        KRYLOV_ORDER_traits::create (i, f, this));

      this->KRYLOV_ORDER_.push_back (r);
      continue;
    }

    // INPUTS
    //
    if (n.name () == "INPUTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< INPUTS_type > r (
        INPUTS_traits::create (i, f, this));

      this->INPUTS_.push_back (r);
      continue;
    }

    // OUTPUTS
    //
    if (n.name () == "OUTPUTS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OUTPUTS_type > r (
        OUTPUTS_traits::create (i, f, this));

      this->OUTPUTS_.push_back (r);
      continue;
    }

    break;
  }
}

ROMDATA* ROMDATA::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ROMDATA (*this, f, c);
}

ROMDATA& ROMDATA::
operator= (const ROMDATA& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->EXP_POINTS_ = x.EXP_POINTS_;
    this->KRYLOV_ORDER_ = x.KRYLOV_ORDER_;
    this->INPUTS_ = x.INPUTS_;
    this->OUTPUTS_ = x.OUTPUTS_;
  }

  return *this;
}

ROMDATA::
~ROMDATA ()
{
}

// FILEIMPORT
//

FILEIMPORT::
FILEIMPORT ()
: ::xml_schema::type (),
  FILE_ (this),
  IMPORT_ (this),
  Type_ (this)
{
}

FILEIMPORT::
FILEIMPORT (const FILEIMPORT& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FILE_ (x.FILE_, f, this),
  IMPORT_ (x.IMPORT_, f, this),
  Type_ (x.Type_, f, this)
{
}

FILEIMPORT::
FILEIMPORT (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FILE_ (this),
  IMPORT_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void FILEIMPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FILE
    //
    if (n.name () == "FILE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< FILE_type > r (
        FILE_traits::create (i, f, this));

      if (!this->FILE_)
      {
        this->FILE_.set (r);
        continue;
      }
    }

    // IMPORT
    //
    if (n.name () == "IMPORT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMPORT_type > r (
        IMPORT_traits::create (i, f, this));

      this->IMPORT_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

FILEIMPORT* FILEIMPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FILEIMPORT (*this, f, c);
}

FILEIMPORT& FILEIMPORT::
operator= (const FILEIMPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FILE_ = x.FILE_;
    this->IMPORT_ = x.IMPORT_;
    this->Type_ = x.Type_;
  }

  return *this;
}

FILEIMPORT::
~FILEIMPORT ()
{
}

// MATERIALS
//

MATERIALS::
MATERIALS ()
: ::xml_schema::type (),
  MATERIAL_ (this)
{
}

MATERIALS::
MATERIALS (const MATERIALS& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MATERIAL_ (x.MATERIAL_, f, this)
{
}

MATERIALS::
MATERIALS (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MATERIAL_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MATERIALS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MATERIAL
    //
    if (n.name () == "MATERIAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIAL_type > r (
        MATERIAL_traits::create (i, f, this));

      this->MATERIAL_.push_back (r);
      continue;
    }

    break;
  }
}

MATERIALS* MATERIALS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIALS (*this, f, c);
}

MATERIALS& MATERIALS::
operator= (const MATERIALS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MATERIAL_ = x.MATERIAL_;
  }

  return *this;
}

MATERIALS::
~MATERIALS ()
{
}

// SECTIONS
//

SECTIONS::
SECTIONS ()
: ::xml_schema::type (),
  SECTION_ (this)
{
}

SECTIONS::
SECTIONS (const SECTIONS& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  SECTION_ (x.SECTION_, f, this)
{
}

SECTIONS::
SECTIONS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  SECTION_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SECTIONS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SECTION
    //
    if (n.name () == "SECTION" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SECTION_type > r (
        SECTION_traits::create (i, f, this));

      this->SECTION_.push_back (r);
      continue;
    }

    break;
  }
}

SECTIONS* SECTIONS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SECTIONS (*this, f, c);
}

SECTIONS& SECTIONS::
operator= (const SECTIONS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->SECTION_ = x.SECTION_;
  }

  return *this;
}

SECTIONS::
~SECTIONS ()
{
}

// SETS
//

SETS::
SETS ()
: ::xml_schema::type (),
  ELEMENTSET_ (this),
  NODESET_ (this)
{
}

SETS::
SETS (const SETS& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENTSET_ (x.ELEMENTSET_, f, this),
  NODESET_ (x.NODESET_, f, this)
{
}

SETS::
SETS (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENTSET_ (this),
  NODESET_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SETS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENTSET
    //
    if (n.name () == "ELEMENTSET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTSET_type > r (
        ELEMENTSET_traits::create (i, f, this));

      this->ELEMENTSET_.push_back (r);
      continue;
    }

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    break;
  }
}

SETS* SETS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SETS (*this, f, c);
}

SETS& SETS::
operator= (const SETS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENTSET_ = x.ELEMENTSET_;
    this->NODESET_ = x.NODESET_;
  }

  return *this;
}

SETS::
~SETS ()
{
}

// LOADS
//

LOADS::
LOADS ()
: ::xml_schema::type (),
  LOAD_ (this)
{
}

LOADS::
LOADS (const LOADS& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LOAD_ (x.LOAD_, f, this)
{
}

LOADS::
LOADS (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LOAD_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LOADS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LOAD
    //
    if (n.name () == "LOAD" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOAD_type > r (
        LOAD_traits::create (i, f, this));

      this->LOAD_.push_back (r);
      continue;
    }

    break;
  }
}

LOADS* LOADS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOADS (*this, f, c);
}

LOADS& LOADS::
operator= (const LOADS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LOAD_ = x.LOAD_;
  }

  return *this;
}

LOADS::
~LOADS ()
{
}

// BC_DEF
//

BC_DEF::
BC_DEF ()
: ::xml_schema::type (),
  DISPLACEMENT_ (this)
{
}

BC_DEF::
BC_DEF (const BC_DEF& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  DISPLACEMENT_ (x.DISPLACEMENT_, f, this)
{
}

BC_DEF::
BC_DEF (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  DISPLACEMENT_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void BC_DEF::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DISPLACEMENT
    //
    if (n.name () == "DISPLACEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DISPLACEMENT_type > r (
        DISPLACEMENT_traits::create (i, f, this));

      this->DISPLACEMENT_.push_back (r);
      continue;
    }

    break;
  }
}

BC_DEF* BC_DEF::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BC_DEF (*this, f, c);
}

BC_DEF& BC_DEF::
operator= (const BC_DEF& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->DISPLACEMENT_ = x.DISPLACEMENT_;
  }

  return *this;
}

BC_DEF::
~BC_DEF ()
{
}

// EXPORT
//

EXPORT::
EXPORT ()
: ::xml_schema::type (),
  INPUT_LOADCASE_ (this),
  OUTPUTS_HISTORY_ (this),
  Type_ (this)
{
}

EXPORT::
EXPORT (const EXPORT& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  INPUT_LOADCASE_ (x.INPUT_LOADCASE_, f, this),
  OUTPUTS_HISTORY_ (x.OUTPUTS_HISTORY_, f, this),
  Type_ (x.Type_, f, this)
{
}

EXPORT::
EXPORT (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  INPUT_LOADCASE_ (this),
  OUTPUTS_HISTORY_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void EXPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // INPUT_LOADCASE
    //
    if (n.name () == "INPUT_LOADCASE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< INPUT_LOADCASE_type > r (
        INPUT_LOADCASE_traits::create (i, f, this));

      this->INPUT_LOADCASE_.push_back (r);
      continue;
    }

    // OUTPUTS_HISTORY
    //
    if (n.name () == "OUTPUTS_HISTORY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OUTPUTS_HISTORY_type > r (
        OUTPUTS_HISTORY_traits::create (i, f, this));

      this->OUTPUTS_HISTORY_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

EXPORT* EXPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EXPORT (*this, f, c);
}

EXPORT& EXPORT::
operator= (const EXPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->INPUT_LOADCASE_ = x.INPUT_LOADCASE_;
    this->OUTPUTS_HISTORY_ = x.OUTPUTS_HISTORY_;
    this->Type_ = x.Type_;
  }

  return *this;
}

EXPORT::
~EXPORT ()
{
}

// BC
//

BC::
BC ()
: ::xml_schema::type (),
  Name_ (this),
  Instance_ (this)
{
}

BC::
BC (const BC& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this),
  Instance_ (x.Instance_, f, this)
{
}

BC::
BC (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this),
  Instance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void BC::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Instance" && n.namespace_ ().empty ())
    {
      this->Instance_.set (Instance_traits::create (i, f, this));
      continue;
    }
  }
}

BC* BC::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class BC (*this, f, c);
}

BC& BC::
operator= (const BC& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
    this->Instance_ = x.Instance_;
  }

  return *this;
}

BC::
~BC ()
{
}

// LOADCASE
//

LOADCASE::
LOADCASE ()
: ::xml_schema::type (),
  START_THETA_ (this),
  END_THETA_ (this),
  STEP_THETA_ (this),
  LOAD_ (this),
  Type_ (this),
  NamePrefix_ (this)
{
}

LOADCASE::
LOADCASE (const LOADCASE& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  START_THETA_ (x.START_THETA_, f, this),
  END_THETA_ (x.END_THETA_, f, this),
  STEP_THETA_ (x.STEP_THETA_, f, this),
  LOAD_ (x.LOAD_, f, this),
  Type_ (x.Type_, f, this),
  NamePrefix_ (x.NamePrefix_, f, this)
{
}

LOADCASE::
LOADCASE (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  START_THETA_ (this),
  END_THETA_ (this),
  STEP_THETA_ (this),
  LOAD_ (this),
  Type_ (this),
  NamePrefix_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void LOADCASE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // START_THETA
    //
    if (n.name () == "START_THETA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< START_THETA_type > r (
        START_THETA_traits::create (i, f, this));

      if (!this->START_THETA_)
      {
        this->START_THETA_.set (r);
        continue;
      }
    }

    // END_THETA
    //
    if (n.name () == "END_THETA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< END_THETA_type > r (
        END_THETA_traits::create (i, f, this));

      if (!this->END_THETA_)
      {
        this->END_THETA_.set (r);
        continue;
      }
    }

    // STEP_THETA
    //
    if (n.name () == "STEP_THETA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< STEP_THETA_type > r (
        STEP_THETA_traits::create (i, f, this));

      if (!this->STEP_THETA_)
      {
        this->STEP_THETA_.set (r);
        continue;
      }
    }

    // LOAD
    //
    if (n.name () == "LOAD" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LOAD_type > r (
        LOAD_traits::create (i, f, this));

      this->LOAD_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "NamePrefix" && n.namespace_ ().empty ())
    {
      this->NamePrefix_.set (NamePrefix_traits::create (i, f, this));
      continue;
    }
  }
}

LOADCASE* LOADCASE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LOADCASE (*this, f, c);
}

LOADCASE& LOADCASE::
operator= (const LOADCASE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->START_THETA_ = x.START_THETA_;
    this->END_THETA_ = x.END_THETA_;
    this->STEP_THETA_ = x.STEP_THETA_;
    this->LOAD_ = x.LOAD_;
    this->Type_ = x.Type_;
    this->NamePrefix_ = x.NamePrefix_;
  }

  return *this;
}

LOADCASE::
~LOADCASE ()
{
}

// EXP_POINTS
//

EXP_POINTS::
EXP_POINTS ()
: ::xml_schema::string (),
  Type_ (this)
{
}

EXP_POINTS::
EXP_POINTS (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

EXP_POINTS::
EXP_POINTS (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

EXP_POINTS::
EXP_POINTS (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

EXP_POINTS::
EXP_POINTS (const EXP_POINTS& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  Type_ (x.Type_, f, this)
{
}

EXP_POINTS::
EXP_POINTS (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void EXP_POINTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

EXP_POINTS* EXP_POINTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class EXP_POINTS (*this, f, c);
}

EXP_POINTS& EXP_POINTS::
operator= (const EXP_POINTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->Type_ = x.Type_;
  }

  return *this;
}

EXP_POINTS::
~EXP_POINTS ()
{
}

// KRYLOV_ORDER
//

KRYLOV_ORDER::
KRYLOV_ORDER ()
: ::xml_schema::string (),
  Type_ (this)
{
}

KRYLOV_ORDER::
KRYLOV_ORDER (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

KRYLOV_ORDER::
KRYLOV_ORDER (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

KRYLOV_ORDER::
KRYLOV_ORDER (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  Type_ (this)
{
}

KRYLOV_ORDER::
KRYLOV_ORDER (const KRYLOV_ORDER& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  Type_ (x.Type_, f, this)
{
}

KRYLOV_ORDER::
KRYLOV_ORDER (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void KRYLOV_ORDER::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

KRYLOV_ORDER* KRYLOV_ORDER::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class KRYLOV_ORDER (*this, f, c);
}

KRYLOV_ORDER& KRYLOV_ORDER::
operator= (const KRYLOV_ORDER& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->Type_ = x.Type_;
  }

  return *this;
}

KRYLOV_ORDER::
~KRYLOV_ORDER ()
{
}

// INPUTS
//

INPUTS::
INPUTS ()
: ::xml_schema::type (),
  NODESET_ (this),
  Type_ (this)
{
}

INPUTS::
INPUTS (const INPUTS& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  Type_ (x.Type_, f, this)
{
}

INPUTS::
INPUTS (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void INPUTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

INPUTS* INPUTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class INPUTS (*this, f, c);
}

INPUTS& INPUTS::
operator= (const INPUTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->Type_ = x.Type_;
  }

  return *this;
}

INPUTS::
~INPUTS ()
{
}

// OUTPUTS
//

OUTPUTS::
OUTPUTS ()
: ::xml_schema::type (),
  Type_ (this)
{
}

OUTPUTS::
OUTPUTS (const OUTPUTS& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Type_ (x.Type_, f, this)
{
}

OUTPUTS::
OUTPUTS (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void OUTPUTS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

OUTPUTS* OUTPUTS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OUTPUTS (*this, f, c);
}

OUTPUTS& OUTPUTS::
operator= (const OUTPUTS& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Type_ = x.Type_;
  }

  return *this;
}

OUTPUTS::
~OUTPUTS ()
{
}

// IMPORT
//

IMPORT::
IMPORT ()
: ::xml_schema::type (),
  LIST_ (this),
  UMA_ (this),
  NODE_ (this),
  ELEMENT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
}

IMPORT::
IMPORT (const IMPORT& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  UMA_ (x.UMA_, f, this),
  NODE_ (x.NODE_, f, this),
  ELEMENT_ (x.ELEMENT_, f, this),
  TRANSLATETO_ (x.TRANSLATETO_, f, this),
  Type_ (x.Type_, f, this)
{
}

IMPORT::
IMPORT (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  UMA_ (this),
  NODE_ (this),
  ELEMENT_ (this),
  TRANSLATETO_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void IMPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    // UMA
    //
    if (n.name () == "UMA" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< UMA_type > r (
        UMA_traits::create (i, f, this));

      this->UMA_.push_back (r);
      continue;
    }

    // NODE
    //
    if (n.name () == "NODE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODE_type > r (
        NODE_traits::create (i, f, this));

      this->NODE_.push_back (r);
      continue;
    }

    // ELEMENT
    //
    if (n.name () == "ELEMENT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENT_type > r (
        ELEMENT_traits::create (i, f, this));

      this->ELEMENT_.push_back (r);
      continue;
    }

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

IMPORT* IMPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class IMPORT (*this, f, c);
}

IMPORT& IMPORT::
operator= (const IMPORT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->UMA_ = x.UMA_;
    this->NODE_ = x.NODE_;
    this->ELEMENT_ = x.ELEMENT_;
    this->TRANSLATETO_ = x.TRANSLATETO_;
    this->Type_ = x.Type_;
  }

  return *this;
}

IMPORT::
~IMPORT ()
{
}

// MATERIAL
//

MATERIAL::
MATERIAL ()
: ::xml_schema::type (),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
}

MATERIAL::
MATERIAL (const MATERIAL& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  E_ (x.E_, f, this),
  nu_ (x.nu_, f, this),
  rho_ (x.rho_, f, this),
  eta_ (x.eta_, f, this),
  Name_ (x.Name_, f, this),
  Type_ (x.Type_, f, this)
{
}

MATERIAL::
MATERIAL (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  E_ (this),
  nu_ (this),
  rho_ (this),
  eta_ (this),
  Name_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MATERIAL::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // E
    //
    if (n.name () == "E" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< E_type > r (
        E_traits::create (i, f, this));

      if (!this->E_)
      {
        this->E_.set (r);
        continue;
      }
    }

    // nu
    //
    if (n.name () == "nu" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nu_type > r (
        nu_traits::create (i, f, this));

      if (!this->nu_)
      {
        this->nu_.set (r);
        continue;
      }
    }

    // rho
    //
    if (n.name () == "rho" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rho_type > r (
        rho_traits::create (i, f, this));

      if (!this->rho_)
      {
        this->rho_.set (r);
        continue;
      }
    }

    // eta
    //
    if (n.name () == "eta" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eta_type > r (
        eta_traits::create (i, f, this));

      if (!this->eta_)
      {
        this->eta_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

MATERIAL* MATERIAL::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MATERIAL (*this, f, c);
}

MATERIAL& MATERIAL::
operator= (const MATERIAL& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->E_ = x.E_;
    this->nu_ = x.nu_;
    this->rho_ = x.rho_;
    this->eta_ = x.eta_;
    this->Name_ = x.Name_;
    this->Type_ = x.Type_;
  }

  return *this;
}

MATERIAL::
~MATERIAL ()
{
}

// SECTION
//

SECTION::
SECTION ()
: ::xml_schema::type (),
  ELEMENTSET_ (this),
  MATERIAL_ (this),
  Name_ (this)
{
}

SECTION::
SECTION (const SECTION& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  ELEMENTSET_ (x.ELEMENTSET_, f, this),
  MATERIAL_ (x.MATERIAL_, f, this),
  Name_ (x.Name_, f, this)
{
}

SECTION::
SECTION (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  ELEMENTSET_ (this),
  MATERIAL_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SECTION::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ELEMENTSET
    //
    if (n.name () == "ELEMENTSET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ELEMENTSET_type > r (
        ELEMENTSET_traits::create (i, f, this));

      if (!this->ELEMENTSET_)
      {
        this->ELEMENTSET_.set (r);
        continue;
      }
    }

    // MATERIAL
    //
    if (n.name () == "MATERIAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MATERIAL_type > r (
        MATERIAL_traits::create (i, f, this));

      if (!this->MATERIAL_)
      {
        this->MATERIAL_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

SECTION* SECTION::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SECTION (*this, f, c);
}

SECTION& SECTION::
operator= (const SECTION& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->ELEMENTSET_ = x.ELEMENTSET_;
    this->MATERIAL_ = x.MATERIAL_;
    this->Name_ = x.Name_;
  }

  return *this;
}

SECTION::
~SECTION ()
{
}

// ELEMENTSET
//

ELEMENTSET::
ELEMENTSET ()
: ::xml_schema::type (),
  LIST_ (this),
  Name_ (this)
{
}

ELEMENTSET::
ELEMENTSET (const ELEMENTSET& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LIST_ (x.LIST_, f, this),
  Name_ (x.Name_, f, this)
{
}

ELEMENTSET::
ELEMENTSET (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LIST_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ELEMENTSET::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LIST
    //
    if (n.name () == "LIST" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< LIST_type > r (
        LIST_traits::create (i, f, this));

      if (!this->LIST_)
      {
        this->LIST_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

ELEMENTSET* ELEMENTSET::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENTSET (*this, f, c);
}

ELEMENTSET& ELEMENTSET::
operator= (const ELEMENTSET& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LIST_ = x.LIST_;
    this->Name_ = x.Name_;
  }

  return *this;
}

ELEMENTSET::
~ELEMENTSET ()
{
}

// DISPLACEMENT
//

DISPLACEMENT::
DISPLACEMENT ()
: ::xml_schema::type (),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Name_ (this)
{
}

DISPLACEMENT::
DISPLACEMENT (const DISPLACEMENT& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  REAL_ (x.REAL_, f, this),
  IMAGINARY_ (x.IMAGINARY_, f, this),
  Name_ (x.Name_, f, this)
{
}

DISPLACEMENT::
DISPLACEMENT (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  REAL_ (this),
  IMAGINARY_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void DISPLACEMENT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    // REAL
    //
    if (n.name () == "REAL" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< REAL_type > r (
        REAL_traits::create (i, f, this));

      this->REAL_.push_back (r);
      continue;
    }

    // IMAGINARY
    //
    if (n.name () == "IMAGINARY" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< IMAGINARY_type > r (
        IMAGINARY_traits::create (i, f, this));

      this->IMAGINARY_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }
}

DISPLACEMENT* DISPLACEMENT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DISPLACEMENT (*this, f, c);
}

DISPLACEMENT& DISPLACEMENT::
operator= (const DISPLACEMENT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->REAL_ = x.REAL_;
    this->IMAGINARY_ = x.IMAGINARY_;
    this->Name_ = x.Name_;
  }

  return *this;
}

DISPLACEMENT::
~DISPLACEMENT ()
{
}

// INPUT_LOADCASE
//

INPUT_LOADCASE::
INPUT_LOADCASE ()
: ::xml_schema::type (),
  NODESET_ (this),
  Type_ (this)
{
}

INPUT_LOADCASE::
INPUT_LOADCASE (const INPUT_LOADCASE& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  NODESET_ (x.NODESET_, f, this),
  Type_ (x.Type_, f, this)
{
}

INPUT_LOADCASE::
INPUT_LOADCASE (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  NODESET_ (this),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void INPUT_LOADCASE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NODESET
    //
    if (n.name () == "NODESET" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NODESET_type > r (
        NODESET_traits::create (i, f, this));

      this->NODESET_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

INPUT_LOADCASE* INPUT_LOADCASE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class INPUT_LOADCASE (*this, f, c);
}

INPUT_LOADCASE& INPUT_LOADCASE::
operator= (const INPUT_LOADCASE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->NODESET_ = x.NODESET_;
    this->Type_ = x.Type_;
  }

  return *this;
}

INPUT_LOADCASE::
~INPUT_LOADCASE ()
{
}

// OUTPUTS_HISTORY
//

OUTPUTS_HISTORY::
OUTPUTS_HISTORY ()
: ::xml_schema::type (),
  Type_ (this)
{
}

OUTPUTS_HISTORY::
OUTPUTS_HISTORY (const OUTPUTS_HISTORY& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Type_ (x.Type_, f, this)
{
}

OUTPUTS_HISTORY::
OUTPUTS_HISTORY (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void OUTPUTS_HISTORY::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

OUTPUTS_HISTORY* OUTPUTS_HISTORY::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OUTPUTS_HISTORY (*this, f, c);
}

OUTPUTS_HISTORY& OUTPUTS_HISTORY::
operator= (const OUTPUTS_HISTORY& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Type_ = x.Type_;
  }

  return *this;
}

OUTPUTS_HISTORY::
~OUTPUTS_HISTORY ()
{
}

// UMA
//

UMA::
UMA ()
: ::xml_schema::type (),
  Type_ (this)
{
}

UMA::
UMA (const UMA& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Type_ (x.Type_, f, this)
{
}

UMA::
UMA (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void UMA::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Type" && n.namespace_ ().empty ())
    {
      this->Type_.set (Type_traits::create (i, f, this));
      continue;
    }
  }
}

UMA* UMA::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class UMA (*this, f, c);
}

UMA& UMA::
operator= (const UMA& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Type_ = x.Type_;
  }

  return *this;
}

UMA::
~UMA ()
{
}

// NODE
//

NODE::
NODE ()
: ::xml_schema::type (),
  TRANSLATETO_ (this)
{
}

NODE::
NODE (const NODE& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TRANSLATETO_ (x.TRANSLATETO_, f, this)
{
}

NODE::
NODE (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TRANSLATETO_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NODE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }
}

NODE* NODE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NODE (*this, f, c);
}

NODE& NODE::
operator= (const NODE& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->TRANSLATETO_ = x.TRANSLATETO_;
  }

  return *this;
}

NODE::
~NODE ()
{
}

// ELEMENT
//

ELEMENT::
ELEMENT ()
: ::xml_schema::type (),
  TRANSLATETO_ (this)
{
}

ELEMENT::
ELEMENT (const ELEMENT& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  TRANSLATETO_ (x.TRANSLATETO_, f, this)
{
}

ELEMENT::
ELEMENT (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  TRANSLATETO_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ELEMENT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TRANSLATETO
    //
    if (n.name () == "TRANSLATETO" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< TRANSLATETO_type > r (
        TRANSLATETO_traits::create (i, f, this));

      this->TRANSLATETO_.push_back (r);
      continue;
    }

    break;
  }
}

ELEMENT* ELEMENT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ELEMENT (*this, f, c);
}

ELEMENT& ELEMENT::
operator= (const ELEMENT& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->TRANSLATETO_ = x.TRANSLATETO_;
  }

  return *this;
}

ELEMENT::
~ELEMENT ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::NODESET_ (isrc, h, f, p);
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::NODESET > (
    ::NODESET_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::NODESET >
NODESET_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::NODESET > (
      ::NODESET_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "NODESET" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODESET > r (
      ::xsd::cxx::tree::traits< ::NODESET, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODESET",
    "");
}

::std::auto_ptr< ::NODESET >
NODESET_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "NODESET" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::NODESET > r (
      ::xsd::cxx::tree::traits< ::NODESET, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "NODESET",
    "");
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::TRANSLATETO_ (isrc, h, f, p);
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::TRANSLATETO > (
    ::TRANSLATETO_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (const ::xercesc::DOMDocument& doc,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::TRANSLATETO > (
      ::TRANSLATETO_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "TRANSLATETO" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TRANSLATETO > r (
      ::xsd::cxx::tree::traits< ::TRANSLATETO, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TRANSLATETO",
    "");
}

::std::auto_ptr< ::TRANSLATETO >
TRANSLATETO_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "TRANSLATETO" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::TRANSLATETO > r (
      ::xsd::cxx::tree::traits< ::TRANSLATETO, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "TRANSLATETO",
    "");
}

::std::auto_ptr< ::LOAD >
LOAD_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::LOAD_ (isrc, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::LOAD_ (isrc, h, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::LOAD_ (isrc, h, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::LOAD_ (isrc, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::LOAD_ (isrc, h, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::LOAD_ (isrc, h, f, p);
}

::std::auto_ptr< ::LOAD >
LOAD_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::LOAD > (
    ::LOAD_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::LOAD >
LOAD_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::LOAD > (
      ::LOAD_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "LOAD" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::LOAD > r (
      ::xsd::cxx::tree::traits< ::LOAD, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "LOAD",
    "");
}

::std::auto_ptr< ::LOAD >
LOAD_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "LOAD" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::LOAD > r (
      ::xsd::cxx::tree::traits< ::LOAD, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "LOAD",
    "");
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::REAL_ (isrc, h, f, p);
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::REAL > (
    ::REAL_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::REAL >
REAL_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::REAL > (
      ::REAL_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "REAL" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::REAL > r (
      ::xsd::cxx::tree::traits< ::REAL, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "REAL",
    "");
}

::std::auto_ptr< ::REAL >
REAL_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "REAL" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::REAL > r (
      ::xsd::cxx::tree::traits< ::REAL, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "REAL",
    "");
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::IMAGINARY_ (isrc, h, f, p);
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::IMAGINARY > (
    ::IMAGINARY_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::IMAGINARY > (
      ::IMAGINARY_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "IMAGINARY" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::IMAGINARY > r (
      ::xsd::cxx::tree::traits< ::IMAGINARY, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "IMAGINARY",
    "");
}

::std::auto_ptr< ::IMAGINARY >
IMAGINARY_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "IMAGINARY" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::IMAGINARY > r (
      ::xsd::cxx::tree::traits< ::IMAGINARY, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "IMAGINARY",
    "");
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::STACCATO_XML_ (isrc, h, f, p);
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::STACCATO_XML > (
    ::STACCATO_XML_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::STACCATO_XML > (
      ::STACCATO_XML_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

::std::auto_ptr< ::STACCATO_XML >
STACCATO_XML_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "STACCATO_XML" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::STACCATO_XML > r (
      ::xsd::cxx::tree::traits< ::STACCATO_XML, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "STACCATO_XML",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

